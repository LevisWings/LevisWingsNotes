# üìö Theory

## Introduction

Malware development is essentially just programming for a very niche purpose, to infect systems (with consent, of course). In a red team/pentest form, this is typically done with the goal of establishing a C2 (Command and Control) session within a target organization. To accomplish this, in most cases we have to attempt to evade defense systems (such as Microsoft AV) in order to successfully inject the malware. The AV industry implements many increasingly complicated detection methods using machine learning and AI.

## PE (Portable Executable)



{% embed url="https://raw.githubusercontent.com/corkami/pics/master/binary/pe101/pe101.png" %}

### General concepts

* file pointer: This is a position within the file as stored on disk.
* Relative virtual address (RVA): In an image file, this is the address of an item after it is loaded into memory, with the base address of the image file subtracted from it. The RVA of an item almost always differs from its position within the file on disk (file pointer).

### Analyze a PE file

There are many ways to analyze a PE file.&#x20;

#### PE-bear

We can use PE-bear:

> "PE-bear is a freeware reversing tool for PE files. Its objective is to deliver fast and flexible ‚Äúfirst view‚Äù for malware analysts, stable and capable to handle malformed PE files."

{% embed url="https://github.com/hasherezade/pe-bear-releases" %}
Download
{% endembed %}

Example with cacl.exe (PE file):

![](../../.gitbook/assets/cacl\_analyze.png)

In a PE file, there are 3 important sections:

* Executable Code Section (**.text**): This section contains all the code in one large section. Since modern OS use paging, having a larger unified code section makes it easier for both the OS and the programmer to manage and develop.This section contains the code from where execution starts and pointers to the import table.
* Data Sections (**.data**, **.rdata**, **.bss**): The **.bss** section type of data section represents uninitialized data. This is to reduce the size of the executable file. Since some variables may not have values until the program is executed, it becomes a waste of space to declare and allocate space in the executable file. Hence the .bss section is used to declare the variables in the memory during execution. The **.rdata** section contains data that is to be only readable, such as literal strings, constants and debug directory information. Data which does not fall into the any of the two above categories, falls into the **.data** section.
* Resources Section: The **.rsrc** section  contains resource information for a module. The first 16 bytes compromises a header like other sections, but this section‚Äôs data is further structured into a hierarchy.

{% embed url="https://keystrokes2016.wordpress.com/2016/06/03/pe-file-structure-sections" %}
Reference
{% endembed %}

#### dumpbin

We can also analyze (and view the sections) of a PE file with the [dumpbin tool](https://docs.microsoft.com/en-us/cpp/build/reference/dumpbin-command-line?view=msvc-170):

```shell
dumpbin /headers C:\Windows\System32\calc.exe
```

### Generate .exe/.dll (Theory)

| EXE                                                                                                                                            | DLL                                                                                                                                                                                                                                 |
| ---------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| Separate programs which can be loaded into memory as an independent process.                                                                   | Dll's or dynamic loaded libraries are pe modules that are loaded into existing processes and cannot live independently in memory.                                                                                                   |
| In a very simplified way, for .exe programs, the SO loader calls the main() function when all the initialization of a new process is finished. | In a very simplified way, for dll's, the SO loader calls the DllMain() function. This function initializes the library and then the loader hands over control to the process so that it can call its functions from the loaded dll. |

To generate a PE file (either `.exe` or `.dll`), we need the source code and a compiler to translate it to "machine code":

![](../../.gitbook/assets/generate\_pe.gif)

## Droppers & Payloads

A **dropper** acts as a carrier or delivery vehicle for the file that is to be dropped, which is referred to as the dropper's _payload_. The payload is usually stored in the dropper's body as a compressed file. Droppers are almost always used to deliver harmful programs.

In computer security, the **payload** refers to the part of the malware that performs the malicious action after successful penetration. That is, the payload is code that executes on the compromised machine and performs a generally malicious action.

So, to store the payload in a dropper, we can do it in the 3 important sections we saw before:

* **.text**: the payload will be stored in a function like, for example, `main()`.
* **.data**: The payload will be stored in a global (read-only) variable.
* **.rsrc**: The payload will be stored in the resource section in a small file containing the malicious code. Specific API calls must be used to extract the payload from this section.

## Obsfuscation

Encryption and, especially, encryption are fundamental to hide or obfuscate our payloads from AV engines, reverse engineer, etc., as they search by string patterns, binary matching, etc.

Definitions of encryption and encoding can be found here:

{% content-ref url="../../general/password-cracking/theory/encoding.md" %}
[encoding.md](../../general/password-cracking/theory/encoding.md)
{% endcontent-ref %}

{% content-ref url="../../general/password-cracking/theory/encryption.md" %}
[encryption.md](../../general/password-cracking/theory/encryption.md)
{% endcontent-ref %}

### Function Call Obfuscation

The functions used by a process are usually available in the import address table. The AV can look at that in a PE file and see that suspicious and common malware functions are in the table. This is all done without running the binary.

So, the obfuscation of a function call comes into play, which is a method to hide the dll's and external functions that will be called during runtime. To achieve this, we must use standard Windows API function calls:

* `GetModuleHandle()`: Retrieves a module handle for the specified module.
* `GetProcAddress()`: Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).

## Trojans & Backdoors

Like their namesake, Trojan horse attacks, or simply Trojans, use deception and social engineering to trick unsuspecting users into running seemingly harmless programs that hide a malicious payload.

For example, a legitimate Windows binary, such as calc.exe, could have malicious code injected into it.

Methods of implementing your own code on a PE file:

### Code cave

A **code cave** is a series of unused bytes in a process's memory. The code cave inside a process's memory is often a reference to a section that has capacity for injecting custom instructions. The concept of a code cave is often employed by [hackers](https://en.wikipedia.org/wiki/Hacker) and [reverse engineers](https://en.wikipedia.org/wiki/Reverse\_engineering) to execute [arbitrary code](https://en.wikipedia.org/wiki/Arbitrary\_code\_execution) in a compiled program. Generally, it is found in the code section (.text). The disadvantage is the available space you have to inject your malware.

### New section

Just as we have the .text, .data, etc. sections, we can also add a new section and inject our malicious code. The problem with this method is that we have to set this section as executable and that is when the alarm bells go off for AVs. An example of what a new section looks like can be found [here](https://www.ired.team/offensive-security/code-injection-process-injection/backdooring-portable-executables-pe-with-shellcode#new-pe-code-section).

### Extending section

This method consists of extending the current section, i.e. increasing its size in order to inject its malicious code.

## Code/Process Injection

Code injection is a way to transfer a payload from one process to another, and then execute it. To achieve this, we need the following:

* Allocate memory inside the target process (example: calc.exe). Remember that the buffer size must be equal or more than the size of our shellcode.
* Then we copy our shellcode to that space in the memory of the target process.
* And finally, we execute the shellcode in the target process.

Common combination:

* [VirtualAllocEx()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex)
* [WriteProcessMemory()](https://docs.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
* [CreateRemoteThread()](https://docs.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)

This technique can be used for the following:

* Evade firewalls or migrate to another context. For example, if the Excel.exe process does not have permissions to exit to the Internet, then we can use this technique to migrate to another process such as chrome.exe and bypass the firewall.
* Escape from unstable or short-lived processes (e.g., the user can close the process).
* Establish a backup "Command and Control" (C2) channel.

### DLL Injection

In [computer programming](https://en.wikipedia.org/wiki/Computer\_programming), **DLL injection** is a technique used for running [code](https://en.wikipedia.org/wiki/Machine\_code) within the [address space](https://en.wikipedia.org/wiki/Address\_space) of another [process](https://en.wikipedia.org/wiki/Process\_\(computing\)) by forcing it to load a [dynamic-link library](https://en.wikipedia.org/wiki/Dynamic-link\_library).

The process to achieve this is as follows:

* Allocate buffer for the DLL path.
* We copy the path of the DLL to the buffer.
* We call to load the library (DLL) remotely. We will need the address of the kernerl32.dll to use the function.
