# PE (Portable Executable)

## Introduction

PE stands for portable executable format, it is a data structure that encapsulates the information necessary for the Windows loader to manage the executable code that surrounds it, i.e., OS loader reads that program from disk and loads it into memory as a process and executes it.

This is the following structure of a Portable Executable (PE):

![](../../.gitbook/assets/Portable\_Executable\_32\_bit.png)

A real example that can summarize this structure would be as follows:

|     Structure     |            Book           |                                  PE file                                 |
| :---------------: | :-----------------------: | :----------------------------------------------------------------------: |
| Metadata - Header | Author, Title, Date, etc. | DOS header, PE header, optional header, data directories, sections table |
|  Data - Sections  |          Content          |                            Code, imports, data                           |

For more information on the structure, [corkami](https://github.com/corkami) has images on this:

{% embed url="https://raw.githubusercontent.com/corkami/pics/master/binary/pe101/pe101.png" %}

## PE format

### DOS Header

#### **Overview**

The DOS header (also called the MS-DOS header) is a 64-byte-long structure that exists at the start of the PE file.

it’s not important for the functionality of PE files on modern Windows systems, however it’s there because of backward compatibility reasons.

This header makes the file an MS-DOS executable, so when it’s loaded on MS-DOS the DOS stub gets executed instead of the actual program.

Without this header, if you attempt to load the executable on MS-DOS it will not be loaded and will just produce a generic error.

#### Structure

As mentioned before, it’s a 64-byte-long structure, we can take a look at the contents of that structure by looking at the `IMAGE_DOS_HEADER` structure definition from `winnt.h`:

```cpp
typedef struct _IMAGE_DOS_HEADER {      // DOS .EXE header
    WORD   e_magic;                     // Magic number
    WORD   e_cblp;                      // Bytes on last page of file
    WORD   e_cp;                        // Pages in file
    WORD   e_crlc;                      // Relocations
    WORD   e_cparhdr;                   // Size of header in paragraphs
    WORD   e_minalloc;                  // Minimum extra paragraphs needed
    WORD   e_maxalloc;                  // Maximum extra paragraphs needed
    WORD   e_ss;                        // Initial (relative) SS value
    WORD   e_sp;                        // Initial SP value
    WORD   e_csum;                      // Checksum
    WORD   e_ip;                        // Initial IP value
    WORD   e_cs;                        // Initial (relative) CS value
    WORD   e_lfarlc;                    // File address of relocation table
    WORD   e_ovno;                      // Overlay number
    WORD   e_res[4];                    // Reserved words
    WORD   e_oemid;                     // OEM identifier (for e_oeminfo)
    WORD   e_oeminfo;                   // OEM information; e_oemid specific
    WORD   e_res2[10];                  // Reserved words
    LONG   e_lfanew;                    // File address of new exe header
  } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;
```

This structure is important to the PE loader on MS-DOS, however only a few members of it are important to the PE loader on Windows Systems, so we’re not going to cover everything in here, just the important members of the structure.

* **`e_magic`:** This is the first member of the DOS Header, it’s a WORD so it occupies 2 bytes, it’s usually called the magic number. It has a fixed value of `0x5A4D` or `MZ` in ASCII, and it serves as a signature that marks the file as an MS-DOS executable.
* **`e_lfanew`:** This is the last member of the DOS header structure, it’s located at offset `0x3C` into the DOS header and it holds an offset to the start of the NT headers. This member is important to the PE loader on Windows systems because it tells the loader where to look for the file header.

The following picture shows contents of the DOS header in an actual PE file using PE-bear:

![](../../.gitbook/assets/dos\_header\_notepad.png)

As you can see, the first member of the header is the magic number with the fixed value we talked about which was `5A4D`.

The last member of the header (at offset `0x3C`) is given the name “File address of new exe header”, it has the value `F0`, we can follow to that offset and we’ll find the start of the NT headers as expected:

![](../../.gitbook/assets/nt\_headers\_pe\_notepad.png)

### NT Headers (IMAGE\_NT\_HEADERS) <a href="#nt-headers-image_nt_headers" id="nt-headers-image_nt_headers"></a>

NT headers is a structure defined in `winnt.h` as `IMAGE_NT_HEADERS`, by looking at its definition we can see that it has three members, a `DWORD` signature, an `IMAGE_FILE_HEADER` structure called `FileHeader` and an `IMAGE_OPTIONAL_HEADER` structure called `OptionalHeader`.\
It’s worth mentioning that this structure is defined in two different versions, one for 32-bit executables (Also named `PE32` executables) named `IMAGE_NT_HEADERS` and one for 64-bit executables (Also named `PE32+` executables) named `IMAGE_NT_HEADERS64`.\
The main difference between the two versions is the used version of `IMAGE_OPTIONAL_HEADER` structure which has two versions, `IMAGE_OPTIONAL_HEADER32` for 32-bit executables and `IMAGE_OPTIONAL_HEADER64` for 64-bit executables.

```cpp
typedef struct _IMAGE_NT_HEADERS64 {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER64 OptionalHeader;
} IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

typedef struct _IMAGE_NT_HEADERS {
    DWORD Signature;
    IMAGE_FILE_HEADER FileHeader;
    IMAGE_OPTIONAL_HEADER32 OptionalHeader;
} IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;
```

#### **Signature**

First member of the NT headers structure is the PE signature, it’s a `DWORD` which means that it occupies 4 bytes.\
It always has a fixed value of `0x50450000` which translates to `PE\0\0` in ASCII.

Here’s a screenshot from PE-bear showing the PE signature:

![](../../.gitbook/assets/nt\_headers\_signature\_notepad.png)

#### **File Header (IMAGE\_FILE\_HEADER)**

Also called “The COFF File Header”, the File Header is a structure that holds some information about the PE file.\
It’s defined as `IMAGE_FILE_HEADER` in `winnt.h`, here’s the definition:

```cpp
typedef struct _IMAGE_FILE_HEADER {
    WORD    Machine;
    WORD    NumberOfSections;
    DWORD   TimeDateStamp;
    DWORD   PointerToSymbolTable;
    DWORD   NumberOfSymbols;
    WORD    SizeOfOptionalHeader;
    WORD    Characteristics;
} IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;
```

It’s a simple structure with 7 members:

* `Machine`**:** This is a number that indicates the type of machine (CPU Architecture) the executable is targeting, this field can have a lot of values, but we’re only interested in two of them, `0x8864` for `AMD64` and `0x14c` for `i386`. For a complete list of possible values you can check the [official Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format).
* `NumberOfSections`**:** This field holds the number of sections (or the number of section headers aka. the size of the section table.).
* `TimeDateStamp`**:** A `unix` timestamp that indicates when the file was created.
* `PointerToSymbolTable` **and** `NumberOfSymbols`**:** These two fields hold the file offset to the COFF symbol table and the number of entries in that symbol table, however they get set to `0` which means that no COFF symbol table is present, this is done because the COFF debugging information is deprecated.
* `SizeOfOptionalHeader`**:** The size of the Optional Header.
* `Characteristics`**:** A flag that indicates the attributes of the file, these attributes can be things like the file being executable, the file being a system file and not a user program, and a lot of other things. A complete list of these flags can be found on the [official Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format).

Here’s the File Header contents of an actual PE file:

![](../../.gitbook/assets/file\_headers\_notepad.png)

#### **Optional Header (IMAGE\_OPTIONAL\_HEADER)**

The Optional Header is the most important header of the NT headers, the PE loader looks for specific information provided by that header to be able to load and run the executable.\
It’s called the optional header because some file types like object files don’t have it, however this header is essential for image files.\
It doesn’t have a fixed size, that’s why the `IMAGE_FILE_HEADER.SizeOfOptionalHeader` member exists.

The first 8 members of the Optional Header structure are standard for every implementation of the COFF file format, the rest of the header is an extension to the standard COFF optional header defined by Microsoft, these additional members of the structure are needed by the Windows PE loader and linker.

As mentioned earlier, there are two versions of the Optional Header, one for 32-bit executables and one for 64-bit executables.\
The two versions are different in two aspects:

* **The size of the structure itself (or the number of members defined within the structure):** `IMAGE_OPTIONAL_HEADER32` has 31 members while `IMAGE_OPTIONAL_HEADER64` only has 30 members, that additional member in the 32-bit version is a DWORD named `BaseOfData` which holds an RVA of the beginning of the data section.
* **The data type of some of the members:** The following 5 members of the Optional Header structure are defined as `DWORD` in the 32-bit version and as `ULONGLONG` in the 64-bit version:
  * **`ImageBase`**
  * **`SizeOfStackReserve`**
  * **`SizeOfStackCommit`**
  * **`SizeOfHeapReserve`**
  * **`SizeOfHeapCommit`**

Let’s take a look at the definition of both structures.

```cpp
typedef struct _IMAGE_OPTIONAL_HEADER {
    //
    // Standard fields.
    //

    WORD    Magic;
    BYTE    MajorLinkerVersion;
    BYTE    MinorLinkerVersion;
    DWORD   SizeOfCode;
    DWORD   SizeOfInitializedData;
    DWORD   SizeOfUninitializedData;
    DWORD   AddressOfEntryPoint;
    DWORD   BaseOfCode;
    DWORD   BaseOfData;

    //
    // NT additional fields.
    //

    DWORD   ImageBase;
    DWORD   SectionAlignment;
    DWORD   FileAlignment;
    WORD    MajorOperatingSystemVersion;
    WORD    MinorOperatingSystemVersion;
    WORD    MajorImageVersion;
    WORD    MinorImageVersion;
    WORD    MajorSubsystemVersion;
    WORD    MinorSubsystemVersion;
    DWORD   Win32VersionValue;
    DWORD   SizeOfImage;
    DWORD   SizeOfHeaders;
    DWORD   CheckSum;
    WORD    Subsystem;
    WORD    DllCharacteristics;
    DWORD   SizeOfStackReserve;
    DWORD   SizeOfStackCommit;
    DWORD   SizeOfHeapReserve;
    DWORD   SizeOfHeapCommit;
    DWORD   LoaderFlags;
    DWORD   NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;
```

```cpp
typedef struct _IMAGE_OPTIONAL_HEADER64 {
    WORD        Magic;
    BYTE        MajorLinkerVersion;
    BYTE        MinorLinkerVersion;
    DWORD       SizeOfCode;
    DWORD       SizeOfInitializedData;
    DWORD       SizeOfUninitializedData;
    DWORD       AddressOfEntryPoint;
    DWORD       BaseOfCode;
    ULONGLONG   ImageBase;
    DWORD       SectionAlignment;
    DWORD       FileAlignment;
    WORD        MajorOperatingSystemVersion;
    WORD        MinorOperatingSystemVersion;
    WORD        MajorImageVersion;
    WORD        MinorImageVersion;
    WORD        MajorSubsystemVersion;
    WORD        MinorSubsystemVersion;
    DWORD       Win32VersionValue;
    DWORD       SizeOfImage;
    DWORD       SizeOfHeaders;
    DWORD       CheckSum;
    WORD        Subsystem;
    WORD        DllCharacteristics;
    ULONGLONG   SizeOfStackReserve;
    ULONGLONG   SizeOfStackCommit;
    ULONGLONG   SizeOfHeapReserve;
    ULONGLONG   SizeOfHeapCommit;
    DWORD       LoaderFlags;
    DWORD       NumberOfRvaAndSizes;
    IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
} IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;
```

*   `Magic`**:** Microsoft documentation describes this field as an integer that identifies the state of the image, the documentation mentions three common values:

    * `0x10B`**:** Identifies the image as a `PE32` executable.
    * `0x20B`**:** Identifies the image as a `PE32+` executable.
    * `0x107`**:** Identifies the image as a ROM image.

    The value of this field is what determines whether the executable is 32-bit or 64-bit, `IMAGE_FILE_HEADER.Machine` is ignored by the Windows PE loader.
* `MajorLinkerVersion` **** and **** `MinorLinkerVersion`**:** The linker major and minor version numbers.
* `SizeOfCode`**:** This field holds the size of the code (`.text`) section, or the sum of all code sections if there are multiple sections.
* `SizeOfInitializedData`**:** This field holds the size of the initialized data (`.data`) section, or the sum of all initialized data sections if there are multiple sections.
* `SizeOfUninitializedData`**:** This field holds the size of the uninitialized data (`.bss`) section, or the sum of all uninitialized data sections if there are multiple sections.
* `AddressOfEntryPoint`**:** An RVA of the entry point when the file is loaded into memory. The documentation states that for program images this relative address points to the starting address and for device drivers it points to initialization function. For DLLs an entry point is optional, and in the case of entry point absence the `AddressOfEntryPoint` field is set to `0`.
* `BaseOfCode`**:** An RVA of the start of the code section when the file is loaded into memory.
* `BaseOfData` **(**`PE32` Only**):** An RVA of the start of the data section when the file is loaded into memory.
* `ImageBase`**:** This field holds the preferred address of the first byte of image when loaded into memory (the preferred base address), this value must be a multiple of 64K. Due to memory protections like ASLR, and a lot of other reasons, the address specified by this field is almost never used, in this case the PE loader chooses an unused memory range to load the image into, after loading the image into that address the loader goes into a process called the relocating where it fixes the constant addresses within the image to work with the new image base, there’s a special section that holds information about places that will need fixing if relocation is needed, that section is called the relocation section (`.reloc`), more on that in the upcoming posts.
* `SectionAlignment`**:** This field holds a value that gets used for section alignment in memory (in bytes), sections are aligned in memory boundaries that are multiples of this value. The documentation states that this value defaults to the page size for the architecture and it can’t be less than the value of `FileAlignment`.
* `FileAlignment`**:** Similar to `SectionAligment` this field holds a value that gets used for section raw data alignment **on disk** (in bytes), if the size of the actual data in a section is less than the `FileAlignment` value, the rest of the chunk gets padded with zeroes to keep the alignment boundaries. The documentation states that this value should be a power of 2 between 512 and 64K, and if the value of `SectionAlignment` is less than the architecture’s page size then the sizes of `FileAlignment` and `SectionAlignment` must match.
* `MajorOperatingSystemVersion`**,** `MinorOperatingSystemVersion`**,** `MajorImageVersion`**,** `MinorImageVersion`**,** `MajorSubsystemVersion` and `MinorSubsystemVersion`**:** These members of the structure specify the major version number of the required operating system, the minor version number of the required operating system, the major version number of the image, the minor version number of the image, the major version number of the subsystem and the minor version number of the subsystem respectively.
* `Win32VersionValue`**:** A reserved field that the documentation says should be set to `0`.
* `SizeOfImage` : The size of the image file (in bytes), including all headers. It gets rounded up to a multiple of `SectionAlignment` because this value is used when loading the image into memory.
* `SizeOfHeaders`**:** The combined size of the DOS stub, PE header (NT Headers), and section headers rounded up to a multiple of `FileAlignment`.
* `CheckSum`**:** A checksum of the image file, it’s used to validate the image at load time.
* `Subsystem`**:** This field specifies the Windows subsystem (if any) that is required to run the image, A complete list of the possible values of this field can be found on the [official Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format).
* `DLLCharacteristics`**:** This field defines some characteristics of the executable image file, like if it’s `NX` compatible and if it can be relocated at run time. I have no idea why it’s named `DLLCharacteristics`, it exists within normal executable image files and it defines characteristics that can apply to normal executable files. A complete list of the possible flags for `DLLCharacteristics` can be found on the [official Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format). Examples:
  * 0x0040: DLL can be relocated at load time. This means that the ImageBase address may change while loading.
* `SizeOfStackReserve`**,** `SizeOfStackCommit`**,** `SizeOfHeapReserve` **and** `SizeOfHeapCommit`**:** These fields specify the size of the stack to reserve, the size of the stack to commit, the size of the local heap space to reserve and the size of the local heap space to commit respectively.
* `LoaderFlags`**:** A reserved field that the documentation says should be set to `0`.
* `NumberOfRvaAndSizes` **:** Size of the `DataDirectory` array.
* `DataDirectory`**:** An array of `IMAGE_DATA_DIRECTORY` structures. We will talk about this in the next post.

Let’s take a look at the Optional Header contents of an actual PE file.

![](../../.gitbook/assets/optional\_headers\_notepad.png)

We can talk about some of these fields, first one being the `Magic` field at the start of the header, it has the value `0x20B` meaning that this is a `PE32+` executable.

We can see that the entry point RVA is `19450` and the code section start RVA is `0x1000`, it follows the alignment defined by the `SectionAlignment` field which has the value of `0x1000`.

File alignment is set to `0x200`, and we can verify this by looking at any of the sections, for example the data section:



### Data Directories <a href="#data-directories" id="data-directories"></a>

The last member of the `IMAGE_OPTIONAL_HEADER` structure was an array of `IMAGE_DATA_DIRECTORY` structures defined as follows:

```
IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES];
```

`IMAGE_NUMBEROF_DIRECTORY_ENTRIES` is a constant defined with the value `16`, meaning that this array can have up to 16 `IMAGE_DATA_DIRECTORY` entries:

```
#define IMAGE_NUMBEROF_DIRECTORY_ENTRIES    16
```

An `IMAGE_DATA_DIRETORY` structure is defines as follows:

```cpp
typedef struct _IMAGE_DATA_DIRECTORY {
    DWORD   VirtualAddress;
    DWORD   Size;
} IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;
```

It’s a very simple structure with only two members, first one being an RVA pointing to the start of the Data Directory and the second one being the size of the Data Directory.

So what is a Data Directory? Basically a Data Directory is a piece of data located within one of the sections of the PE file.\
Data Directories contain useful information needed by the loader, an example of a very important directory is the Import Directory which contains a list of external functions imported from other libraries, we’ll discuss it in more detail when we go over PE imports.

Please note that not all Data Directories have the same structure, the `IMAGE_DATA_DIRECTORY.VirtualAddress` points to the Data Directory, however the type of that directory is what determines how that chunk of data is going to be parsed.

Here’s a list of Data Directories defined in `winnt.h`. (Each one of these values represents an index in the DataDirectory array):

```cpp
// Directory Entries

#define IMAGE_DIRECTORY_ENTRY_EXPORT          0   // Export Directory
#define IMAGE_DIRECTORY_ENTRY_IMPORT          1   // Import Directory
#define IMAGE_DIRECTORY_ENTRY_RESOURCE        2   // Resource Directory
#define IMAGE_DIRECTORY_ENTRY_EXCEPTION       3   // Exception Directory
#define IMAGE_DIRECTORY_ENTRY_SECURITY        4   // Security Directory
#define IMAGE_DIRECTORY_ENTRY_BASERELOC       5   // Base Relocation Table
#define IMAGE_DIRECTORY_ENTRY_DEBUG           6   // Debug Directory
//      IMAGE_DIRECTORY_ENTRY_COPYRIGHT       7   // (X86 usage)
#define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7   // Architecture Specific Data
#define IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8   // RVA of GP
#define IMAGE_DIRECTORY_ENTRY_TLS             9   // TLS Directory
#define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10   // Load Configuration Directory
#define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11   // Bound Import Directory in headers
#define IMAGE_DIRECTORY_ENTRY_IAT            12   // Import Address Table
#define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13   // Delay Load Import Descriptors
#define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14   // COM Runtime descriptor
```

If we take a look at the contents of `IMAGE_OPTIONAL_HEADER.DataDirectory` of an actual PE file, we might see entries where both fields are set to `0`:

![](../../.gitbook/assets/data\_directory\_notepad.png)

This means that this specific Data Directory is not used (doesn’t exist) in the executable file.

### **Sections**

Sections are the containers of the actual data of the executable file, they occupy the rest of the PE file after the headers, precisely after the section headers.\
Some sections have special names that indicate their purpose, we’ll go over some of them, and a full list of these names can be found on the [official Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format) under the “Special Sections” section.

* **`.text`:** Contains the executable code of the program.
* **`.data`:** Contains the initialized data.
* **`.bss`:** Contains uninitialized data.
* **`.rdata`:** Contains read-only initialized data.
* **`.edata`:** Contains the export tables.
* **`.idata`:** Contains the import tables.
* **`.reloc`:** Contains image relocation information.
* **`.rsrc`:** Contains resources used by the program, these include images, icons or even embedded binaries.
* **`.tls`:** (**T**hread **L**ocal **S**torage), provides storage for every executing thread of the program.

![](../../.gitbook/assets/sections\_notepad.png)

### **Section Headers**

After the Optional Header and before the sections comes the Section Headers. These headers contain information about the sections of the PE file.

A Section Header is a structure named `IMAGE_SECTION_HEADER` defined in `winnt.h` as follows:

```cpp
typedef struct _IMAGE_SECTION_HEADER {
    BYTE    Name[IMAGE_SIZEOF_SHORT_NAME];
    union {
            DWORD   PhysicalAddress;
            DWORD   VirtualSize;
    } Misc;
    DWORD   VirtualAddress;
    DWORD   SizeOfRawData;
    DWORD   PointerToRawData;
    DWORD   PointerToRelocations;
    DWORD   PointerToLinenumbers;
    WORD    NumberOfRelocations;
    WORD    NumberOfLinenumbers;
    DWORD   Characteristics;
} IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;
```

* `Name`**:** First field of the Section Header, a byte array of the size `IMAGE_SIZEOF_SHORT_NAME` that holds the name of the section. `IMAGE_SIZEOF_SHORT_NAME` has the value of `8` meaning that a section name can’t be longer than 8 characters. For longer names the official documentation mentions a work-around by filling this field with an offset in the string table, however executable images do not use a string table so this limitation of 8 characters holds for executable images.
* `PhysicalAddress` or `VirtualSize`**:** A `union` defines multiple names for the same thing, this field contains the total size of the section when it’s loaded in memory.
* `VirtualAddress`**:** The documentation states that for executable images this field holds the address of the first byte of the section relative to the image base when loaded in memory, and for object files it holds the address of the first byte of the section before relocation is applied.
* `SizeOfRawData`**:** This field contains the size of the section on disk, it must be a multiple of `IMAGE_OPTIONAL_HEADER.FileAlignment`.\
  `SizeOfRawData` and `VirtualSize` can be different, we’ll discuss the reason for this later in the post.
* `PointerToRawData`**:** A pointer to the first page of the section within the file, for executable images it must be a multiple of `IMAGE_OPTIONAL_HEADER.FileAlignment`.
* `PointerToRelocations`**:** A file pointer to the beginning of relocation entries for the section. It’s set to `0` for executable files.
* `PointerToLineNumbers`**:** A file pointer to the beginning of COFF line-number entries for the section. It’s set to `0` because COFF debugging information is deprecated.
* `NumberOfRelocations`**:** The number of relocation entries for the section, it’s set to `0` for executable images.
* `NumberOfLinenumbers`**:** The number of COFF line-number entries for the section, it’s set to `0` because COFF debugging information is deprecated.
* `Characteristics`**:** Flags that describe the characteristics of the section.\
  These characteristics are things like if the section contains executable code, contains initialized/uninitialized data, can be shared in memory.\
  A complete list of section characteristics flags can be found on the [official Microsoft documentation](https://docs.microsoft.com/en-us/windows/win32/debug/pe-format).

`SizeOfRawData` and `VirtualSize` can be different, and this can happen for multiple of reasons.

`SizeOfRawData` must be a multiple of `IMAGE_OPTIONAL_HEADER.FileAlignment`, so if the section size is less than that value the rest gets padded and `SizeOfRawData` gets rounded to the nearest multiple of `IMAGE_OPTIONAL_HEADER.FileAlignment`.\
However when the section is loaded into memory it doesn’t follow that alignment and only the actual size of the section is occupied.\
In this case `SizeOfRawData` will be greater than `VirtualSize`

The opposite can happen as well.\
If the section contains uninitialized data, these data won’t be accounted for on disk, but when the section gets mapped into memory, the section will expand to reserve memory space for when the uninitialized data gets later initialized and used.\
This means that the section on disk will occupy less than it will do in memory, in this case `VirtualSize` will be greater than `SizeOfRawData`.

### Translate the RVA to the virtual address in memory

{% hint style="info" %}
Example to get to the "Import Address Table".
{% endhint %}

For this, we need:

* RVA address:

![](../../.gitbook/assets/rva\_import\_address\_table\_notepad.png)

* Base address:

![](../../.gitbook/assets/base\_address\_notepad.png)

With these 2 addresses, we are going to add them together:

* CPU -> Right click on the hexadecimal part -> Go to -> Expression

![](../../.gitbook/assets/go\_to\_expression\_notepad.png)

* We add both addresses.

